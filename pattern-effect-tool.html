<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pattern Effect Tool</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
  <script src="https://unpkg.com/meyda@5.2.1/dist/web/meyda.min.js"></script>
  <script src="https://sdk.scdn.co/spotify-player.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #ffffff;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    #glCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .controls-panel {
      position: fixed;
      top: 30px;
      right: 30px;
      width: 400px;
      display: flex;
      flex-direction: column;
      gap: 1.5px;
      opacity: 1;
      transition: opacity 0.6s ease-out;
    }

    .controls-panel.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .section {
      background: transparent;
    }

    .row {
      height: 54px;
      display: flex;
      align-items: center;
      padding: 0 20px;
      cursor: pointer;
      position: relative;
      transition: background 0.15s ease;
      background: rgba(0,0,0,0.12);
    }

    .row:hover {
      background: rgba(0,0,0,0.35);
    }

    .row-header {
      justify-content: space-between;
      background: rgba(38, 41, 47, 0.7);
      backdrop-filter: blur(20px);
    }

    .row-header .label {
      font-size: 13.5px;
      font-weight: 700;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
    }

    .row-header .arrow {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 5px solid #fff;
      transition: transform 0.4s ease;
    }

    .section.collapsed .row-header .arrow {
      transform: rotate(-90deg);
    }

    .row-header .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .row-header .toggle-btn {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 3px;
      background: rgba(0,0,0,0.35);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s ease;
    }

    .row-header .toggle-btn:hover {
      background: rgba(0,0,0,0.5);
    }

    .row-header .toggle-btn .check {
      opacity: 0.3;
      transition: opacity 0.15s ease;
    }

    .row-header .toggle-btn.active .check {
      opacity: 1;
    }

    .section-content {
      display: flex;
      flex-direction: column;
    }

    .section-content .row {
      height: 54px;
      padding: 0;
      overflow: hidden;
      flex-shrink: 0;
      background: rgba(45, 48, 54, 0.7);
      backdrop-filter: blur(20px);
      transition: height 0.4s ease var(--row-delay, 0s);
      display: block;
    }

    .section-content .row-inner {
      height: 54px;
      display: flex;
      align-items: center;
      padding: 0 20px;
      transform: translateY(0);
      transition: transform 0.4s ease var(--row-delay, 0s);
    }

    .section-content .row-option .row-inner {
      justify-content: space-between;
      width: 100%;
    }

    .section-content .row-slider .row-inner {
      width: 100%;
    }

    .section-content .row:hover {
      background: rgba(0,0,0,0.35);
    }

    .section-content .row.row-slider,
    .section-content .row.row-option,
    .section-content .row.row-option-group {
      background: rgba(58, 62, 68, 0.7);
    }

    .section-content .row.row-slider:hover,
    .section-content .row.row-option:hover,
    .section-content .row.row-option-group:hover {
      background: rgba(0,0,0,0.35);
    }

    .section.collapsed .section-content .row {
      height: 0;
    }

    .section.collapsed .section-content .row-inner {
      transform: translateY(-54px);
    }

    .row-option {
      justify-content: space-between;
    }

    .row-option .label {
      font-size: 13.5px;
      font-weight: 400;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
    }

    .row-option .check {
      opacity: 0;
      transition: opacity 0.15s ease;
    }

    .row-option.active .check {
      opacity: 1;
    }

    .check svg {
      width: 16px;
      height: 16px;
      color: #fff;
    }

    .row-option + .row-slider .row-inner,
    .row-slider + .row-slider .row-inner,
    .row-option + .row-option .row-inner,
    .row-slider + .row-option .row-inner,
    .row-slider + .row-option-group .row-inner {
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .row-option-group .row-inner {
      justify-content: space-between;
      width: 100%;
    }

    .row-option-group .label {
      font-size: 13.5px;
      font-weight: 400;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
    }

    .option-buttons {
      display: flex;
      gap: 1px;
      background: rgba(0,0,0,0.35);
      border-radius: 3px;
      padding: 4px;
    }

    .option-btn {
      padding: 4px 8px;
      border: none;
      border-radius: 2px;
      background: transparent;
      color: #fff;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: -0.25px;
      line-height: 1;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .option-btn:hover {
      background: rgba(255,255,255,0.15);
    }

    .option-btn.active {
      background: rgba(255,255,255,0.25);
    }

    .row-slider .label {
      font-size: 13.5px;
      font-weight: 400;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
      flex-shrink: 0;
      width: 80px;
      margin-right: 40px;
    }

    .slider-wrapper {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      margin-right: 20px;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 2px;
      background: linear-gradient(to right, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.9) var(--value-percent, 50%), rgba(255,255,255,0.25) var(--value-percent, 50%), rgba(255,255,255,0.25) 100%);
      border-radius: 1px;
      outline: none;
      cursor: pointer;
      margin: 0;
      padding: 0;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 4.5px;
      height: 9px;
      background: #fff;
      border-radius: 1px;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 4.5px;
      height: 9px;
      background: #fff;
      border-radius: 1px;
      cursor: pointer;
      border: none;
    }

    input[type="range"]::-moz-range-progress {
      background: rgba(255,255,255,0.9);
      height: 2px;
    }

    .slider-value {
      padding: 4px;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: -0.25px;
      line-height: 1;
      font-variant-numeric: tabular-nums;
      color: #fff;
      text-align: center;
      flex-shrink: 0;
      background: rgba(0,0,0,0.35);
      border-radius: 3px;
    }

    .button-row {
      display: flex;
      gap: 1px;
    }

    .btn {
      flex: 1;
      height: 54px;
      font-size: 13.5px;
      font-weight: 700;
      letter-spacing: -0.25px;
      line-height: 1;
      cursor: pointer;
      transition: background 0.15s ease;
      background: rgba(38, 41, 47, 0.7);
      backdrop-filter: blur(20px);
      border: none;
      color: #fff;
      font-family: inherit;
    }

    .btn:hover {
      background: rgba(0,0,0,0.35);
    }

    .drop-zone {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 10;
    }

    .drop-zone.active {
      opacity: 1;
      pointer-events: auto;
    }

    .drop-zone-content {
      text-align: center;
      color: rgba(255,255,255,0.7);
    }

    .drop-zone-content svg {
      width: 48px;
      height: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    #fileInput {
      display: none;
    }

    /* Audio Controls Panel - positioned bottom left, uses same styles as controls-panel */
    .audio-panel {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 400px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 1.5px;
    }

    .audio-panel .btn.active {
      background: rgba(40, 75, 50, 0.7);
    }

    .audio-panel .btn.active:hover {
      background: rgba(0,0,0,0.35);
    }

    #audioMicBtn.active {
      background: rgba(120, 40, 40, 0.7);
    }

    #audioMicBtn.active:hover {
      background: rgba(0,0,0,0.35);
    }

    #spotifyBtn.active {
      background: rgba(30, 215, 96, 0.7);
    }

    #spotifyBtn.active:hover {
      background: rgba(0,0,0,0.35);
    }

    #spotifyBtn.connecting {
      background: rgba(30, 215, 96, 0.4);
      animation: spotifyPulse 1.5s infinite;
    }

    @keyframes spotifyPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    #spotify-track-info {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.7);
      padding: 8px 12px;
      background: rgba(30, 215, 96, 0.15);
      border-radius: 4px;
      margin-top: 4px;
      display: none;
    }

    #spotify-track-info.visible {
      display: block;
    }

    .audio-panel .row-option {
      padding: 0;
      background: rgba(58, 62, 68, 0.7);
      backdrop-filter: blur(20px);
    }

    .audio-panel .row-option:hover {
      background: rgba(0,0,0,0.35);
    }

    .audio-panel .row-option .row-inner {
      height: 54px;
      display: flex;
      align-items: center;
      padding: 0 20px;
      justify-content: space-between;
      width: 100%;
    }

    #audioFileInput {
      display: none;
    }

    /* Mode Toggle Buttons */
    .mode-toggle {
      position: fixed;
      top: 30px;
      left: 30px;
      z-index: 1001;
      width: 400px;
      display: flex;
      gap: 1px;
    }

    .mode-btn {
      flex: 1;
      height: 54px;
      background: rgba(38, 41, 47, 0.7);
      backdrop-filter: blur(20px);
      border: none;
      color: #fff;
      font-family: inherit;
      font-size: 13.5px;
      font-weight: 700;
      letter-spacing: -0.25px;
      line-height: 1;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .mode-btn:hover,
    .mode-btn.active {
      background: rgba(0,0,0,0.35);
    }

    /* Display Options (below mode toggle) */
    .display-options {
      position: fixed;
      top: 85.5px;
      left: 30px;
      z-index: 1001;
      width: 400px;
      display: flex;
      flex-direction: column;
    }

    .display-options .row {
      padding: 0;
      background: rgba(58, 62, 68, 0.7);
      backdrop-filter: blur(20px);
    }

    .display-options .row:hover {
      background: rgba(0,0,0,0.35);
    }

    .display-options .row-inner {
      height: 54px;
      display: flex;
      align-items: center;
      padding: 0 20px;
      justify-content: space-between;
      width: 100%;
    }

    .display-options .row-option + .row-option .row-inner {
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    /* Text Stack (hover mode only) */
    .text-stack {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      text-align: left;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.6s ease-out;
      z-index: 10;
    }

    .text-stack.visible {
      opacity: 1;
    }

    .text-stack__header {
      font-size: 32px;
      line-height: 32px;
      font-weight: 700;
      color: #000;
      text-transform: uppercase;
      margin: 0;
    }

    .text-stack__paragraph {
      font-size: 16px;
      line-height: 20.8px;
      font-weight: 400;
      color: #000;
      margin: 22px 0 0 0;
    }

    .text-stack__label {
      font-size: 12px;
      line-height: 10.8px;
      font-weight: 700;
      color: #767676;
      text-transform: uppercase;
      margin: 22px 0 0 0;
    }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>

  <!-- Text Stack (hover mode only) -->
  <div class="text-stack" id="textStack">
    <h1 class="text-stack__header">POKEMON</h1>
    <p class="text-stack__paragraph">A piece of music featuring the iconic character Snorlax, striking the balance between the enchanting and nostalgic childhood moments.</p>
    <p class="text-stack__label">ENTERTAINMENT</p>
  </div>

  <!-- Mode Toggle -->
  <div class="mode-toggle">
    <button class="mode-btn active" data-mode="edit">EDIT MODE</button>
    <button class="mode-btn" data-mode="hover">HOVER MODE</button>
  </div>

  <!-- Display Options -->
  <div class="display-options">
    <div class="row row-option active" data-effect="image">
      <div class="row-inner">
        <span class="label">IMAGE</span>
        <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
      </div>
    </div>
    <div class="row row-option" data-effect="wireframe">
      <div class="row-inner">
        <span class="label">WIREFRAME</span>
        <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
      </div>
    </div>
  </div>

  <div class="drop-zone" id="dropZone">
    <div class="drop-zone-content">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
      </svg>
      <p>Drop image here</p>
    </div>
  </div>

  <div class="controls-panel">
    <div class="section">
      <div class="row row-header">
        <span class="label">PATTERN</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option active" data-effect="pattern-ripple">
          <div class="row-inner">
            <span class="label">RIPPLE</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-option" data-effect="pattern-waveform">
          <div class="row-inner">
            <span class="label">WAVEFORM</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider ripple-slider">
          <div class="row-inner">
            <span class="label">FREQUENCY</span>
            <div class="slider-wrapper">
              <input type="range" id="rippleFreq" min="1" max="20" step="0.1" value="13.5">
            </div>
            <span class="slider-value" id="rippleFreqValue">13.5</span>
          </div>
        </div>
        <div class="row row-slider ripple-slider">
          <div class="row-inner">
            <span class="label">AMPLITUDE</span>
            <div class="slider-wrapper">
              <input type="range" id="rippleAmplitude" min="0.01" max="0.20" step="0.01" value="0.05">
            </div>
            <span class="slider-value" id="rippleAmplitudeValue">0.05</span>
          </div>
        </div>
        <div class="row row-slider ripple-slider">
          <div class="row-inner">
            <span class="label">SPEED</span>
            <div class="slider-wrapper">
              <input type="range" id="rippleSpeed" min="0.01" max="0.10" step="0.01" value="0.05">
            </div>
            <span class="slider-value" id="rippleSpeedValue">0.05</span>
          </div>
        </div>
        <div class="row row-option ripple-slider" data-effect="ripple-edge-damping">
          <div class="row-inner">
            <span class="label">EDGE DAMPING</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider waveform-slider" style="display: none;">
          <div class="row-inner">
            <span class="label">AMPLITUDE</span>
            <div class="slider-wrapper">
              <input type="range" id="waveformAmplitude" min="0.1" max="2.0" step="0.05" value="0.8">
            </div>
            <span class="slider-value" id="waveformAmplitudeValue">0.80</span>
          </div>
        </div>
        <div class="row row-slider waveform-slider" style="display: none;">
          <div class="row-inner">
            <span class="label">SENSITIVITY</span>
            <div class="slider-wrapper">
              <input type="range" id="waveformSensitivity" min="0" max="100" step="1" value="50">
            </div>
            <span class="slider-value" id="waveformSensitivityValue">50</span>
          </div>
        </div>
        <div class="row row-option-group waveform-slider" style="display: none;">
          <div class="row-inner">
            <span class="label">DIRECTION</span>
            <div class="option-buttons">
              <button class="option-btn active" data-waveform-dir="left-to-right">LEFT</button>
              <button class="option-btn" data-waveform-dir="top-to-bottom">TOP</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section collapsed">
      <div class="row row-header">
        <span class="label">PALETTE</span>
        <div class="header-right">
          <button class="toggle-btn active" data-effect="palette">
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </button>
          <span class="arrow"></span>
        </div>
      </div>
      <div class="section-content">
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">SPEED</span>
            <div class="slider-wrapper">
              <input type="range" id="speed" min="0" max="1" step="0.01" value="0.5">
            </div>
            <span class="slider-value" id="speedValue">0.50</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">FREQUENCY</span>
            <div class="slider-wrapper">
              <input type="range" id="frequency" min="0.5" max="10" step="0.01" value="4">
            </div>
            <span class="slider-value" id="frequencyValue">4.00</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">INTENSITY</span>
            <div class="slider-wrapper">
              <input type="range" id="intensity" min="0" max="10" step="0.01" value="2.5">
            </div>
            <span class="slider-value" id="intensityValue">2.50</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">STRENGTH</span>
            <div class="slider-wrapper">
              <input type="range" id="strength" min="0" max="10" step="0.01" value="2.5">
            </div>
            <span class="slider-value" id="strengthValue">2.50</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section collapsed">
      <div class="row row-header">
        <span class="label">BLOOM</span>
        <div class="header-right">
          <button class="toggle-btn active" data-effect="bloom">
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </button>
          <span class="arrow"></span>
        </div>
      </div>
      <div class="section-content">
        <div class="row row-slider" id="bloomIntensityRow">
          <div class="row-inner">
            <span class="label">INTENSITY</span>
            <div class="slider-wrapper">
              <input type="range" id="bloomIntensity" min="1" max="10" step="0.1" value="7.5">
            </div>
            <span class="slider-value" id="bloomIntensityValue">7.5</span>
          </div>
        </div>
        <div class="row row-slider" id="bloomThresholdRow">
          <div class="row-inner">
            <span class="label">THRESHOLD</span>
            <div class="slider-wrapper">
              <input type="range" id="bloomThreshold" min="1" max="10" step="0.1" value="5">
            </div>
            <span class="slider-value" id="bloomThresholdValue">5.0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section collapsed">
      <div class="row row-header">
        <span class="label">BLUR</span>
        <div class="header-right">
          <button class="toggle-btn active" data-effect="blur">
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </button>
          <span class="arrow"></span>
        </div>
      </div>
      <div class="section-content">
        <div class="row row-slider" id="blurStrengthRow">
          <div class="row-inner">
            <span class="label">STRENGTH</span>
            <div class="slider-wrapper">
              <input type="range" id="blurStrength" min="1" max="10" step="0.1" value="5">
            </div>
            <span class="slider-value" id="blurStrengthValue">5.0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section collapsed">
      <div class="row row-header">
        <span class="label">GRAIN</span>
        <div class="header-right">
          <button class="toggle-btn active" data-effect="grain">
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </button>
          <span class="arrow"></span>
        </div>
      </div>
      <div class="section-content">
        <div class="row row-option active" data-effect="grainAnimated">
          <div class="row-inner">
            <span class="label">ANIMATED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">INTENSITY</span>
            <div class="slider-wrapper">
              <input type="range" id="grainIntensity" min="0.005" max="0.10" step="0.005" value="0.02">
            </div>
            <span class="slider-value" id="grainIntensityValue">0.020</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">SCALE</span>
            <div class="slider-wrapper">
              <input type="range" id="grainScale" min="0.001" max="50" step="0.001" value="2.5">
            </div>
            <span class="slider-value" id="grainScaleValue">2.500</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">SPEED</span>
            <div class="slider-wrapper">
              <input type="range" id="grainSpeed" min="0.001" max="1" step="0.001" value="0.75">
            </div>
            <span class="slider-value" id="grainSpeedValue">0.750</span>
          </div>
        </div>
      </div>
    </div>

    <div class="button-row">
      <button class="btn" id="newImageBtn">NEW IMAGE</button>
      <button class="btn" id="resetBtn">RESET</button>
    </div>
  </div>

  <!-- Audio Controls Panel -->
  <div class="audio-panel">
    <div class="row row-option" id="audio-play-toggle">
      <div class="row-inner">
        <span class="label">PLAY/PAUSE</span>
        <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
      </div>
    </div>
    <div class="button-row">
      <button class="btn" id="audioChooseFileBtn">CHOOSE FILE</button>
      <button class="btn" id="audioMicBtn">USE MIC</button>
      <button class="btn" id="spotifyBtn">SPOTIFY</button>
    </div>
    <div id="spotify-track-info"></div>
    <input type="file" id="audioFileInput" accept="audio/*" />
  </div>

  <input type="file" id="fileInput" accept="image/*">

  <script>
    // =====================================================
    // Spotify Configuration
    // =====================================================
    const SPOTIFY_CONFIG = {
      clientId: 'YOUR_CLIENT_ID_HERE', // Replace with your Spotify App Client ID from developer.spotify.com
      redirectUri: window.location.origin + window.location.pathname,
      scopes: ['streaming', 'user-read-email', 'user-read-private', 'user-modify-playback-state', 'user-read-playback-state']
    };

    // =====================================================
    // AudioAnalyzer Class (ported from demo8)
    // =====================================================
    class AudioAnalyzer {
      constructor(options = {}) {
        this.bufferSize = options.bufferSize || 512;

        this.audioContext = null;
        this.source = null;
        this.audioElement = null;
        this.mediaStream = null;
        this.meydaAnalyzer = null;
        this.analyser = null;           // Web Audio AnalyserNode for time-domain data
        this.timeDomainData = null;     // Uint8Array for waveform samples
        this.isInitialized = false;
        this.sourceType = 'file';
        this.isPlaying = false;
        this.spotifyPlayer = null;

        this.defaultAmplitude = 0;
        this.currentAmplitude = this.defaultAmplitude;

        // Energy tracking for manual flux calculation
        this.previousRms = 0;
        this.rms = 0;

        // Envelope state
        this.envelopeValue = 0;
        this.attackSpeed = 0.9;
        this.decaySpeed = 0.85;

        // Adaptive threshold
        this.rmsHistory = [];
        this.historySize = 43;
        this.sensitivity = 1.3;
        this.minThreshold = 0.01;

        // Peak tracking for dynamic range
        this.peakRms = 0.01;
        this.peakDecay = 0.995;
      }

      async init() {
        if (this.isInitialized) return;

        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Create analyser for time-domain waveform data
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = 256; // Gives 256 time-domain samples
        this.timeDomainData = new Uint8Array(this.analyser.fftSize);

        this.isInitialized = true;
      }

      setupMeydaAnalyzer() {
        if (this.meydaAnalyzer) {
          this.meydaAnalyzer.stop();
        }

        if (!this.source) return;

        if (typeof Meyda === 'undefined') {
          console.warn('Meyda not loaded - audio analysis unavailable');
          return;
        }

        this.meydaAnalyzer = Meyda.createMeydaAnalyzer({
          audioContext: this.audioContext,
          source: this.source,
          bufferSize: this.bufferSize,
          featureExtractors: ['rms'],
          callback: (features) => {
            if (features && typeof features.rms === 'number') {
              this.previousRms = this.rms;
              this.rms = features.rms;
              this.processFeatures();
            }
          },
        });

        this.meydaAnalyzer.start();
      }

      processFeatures() {
        const flux = Math.max(0, this.rms - this.previousRms);

        if (this.rms > this.peakRms) {
          this.peakRms = this.rms;
        } else {
          this.peakRms *= this.peakDecay;
          this.peakRms = Math.max(this.peakRms, 0.01);
        }

        this.rmsHistory.push(flux);
        if (this.rmsHistory.length > this.historySize) {
          this.rmsHistory.shift();
        }

        const avgFlux = this.rmsHistory.reduce((a, b) => a + b, 0) / this.rmsHistory.length;
        const threshold = Math.max(avgFlux * this.sensitivity, this.minThreshold);

        if (flux > threshold) {
          const relativeIntensity = this.rms / this.peakRms;
          const fluxIntensity = Math.min(flux / threshold, 4) / 4;
          const strength = Math.pow(relativeIntensity, 0.7) * (0.5 + fluxIntensity * 0.5);
          this.envelopeValue = this.envelopeValue + (strength - this.envelopeValue) * this.attackSpeed;
        } else {
          this.envelopeValue *= this.decaySpeed;
        }

        this.currentAmplitude = Math.min(Math.max(this.envelopeValue, 0), 1);
      }

      async loadAudioFile(url) {
        await this.init();
        this.disconnectSource();

        if (!this.audioElement) {
          this.audioElement = new Audio();
          this.audioElement.crossOrigin = 'anonymous';
          this.audioElement.loop = true;
        }

        this.audioElement.src = url;

        this.source = this.audioContext.createMediaElementSource(this.audioElement);
        // Connect through analyser for time-domain data
        this.source.connect(this.analyser);
        this.analyser.connect(this.audioContext.destination);

        this.setupMeydaAnalyzer();
        this.sourceType = 'file';

        return new Promise((resolve, reject) => {
          this.audioElement.addEventListener('canplaythrough', () => resolve(), { once: true });
          this.audioElement.addEventListener('error', reject, { once: true });
          this.audioElement.load();
        });
      }

      async connectMicrophone() {
        await this.init();
        this.disconnectSource();

        try {
          this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.source = this.audioContext.createMediaStreamSource(this.mediaStream);
          // Connect to analyser for time-domain data (no destination for mic)
          this.source.connect(this.analyser);

          this.setupMeydaAnalyzer();
          this.sourceType = 'mic';
          this.isPlaying = true;
        } catch (error) {
          console.error('Microphone access denied:', error);
          throw error;
        }
      }

      connectSpotify(spotifyPlayer) {
        this.disconnectSource();
        this.spotifyPlayer = spotifyPlayer;
        this.sourceType = 'spotify';
        this.isPlaying = spotifyPlayer.isPlaying;
      }

      disconnectSource() {
        if (this.meydaAnalyzer) {
          this.meydaAnalyzer.stop();
          this.meydaAnalyzer = null;
        }

        if (this.source) {
          this.source.disconnect();
          this.source = null;
        }

        if (this.mediaStream) {
          this.mediaStream.getTracks().forEach(track => track.stop());
          this.mediaStream = null;
        }

        if (this.audioElement) {
          this.audioElement.pause();
          this.audioElement.src = '';
          this.audioElement = null;
        }

        if (this.spotifyPlayer) {
          this.spotifyPlayer = null;
        }

        this.rmsHistory = [];
        this.envelopeValue = 0;
        this.previousRms = 0;
        this.rms = 0;
        this.peakRms = 0.01;
        this.isPlaying = false;
      }

      async togglePlay() {
        if (this.sourceType !== 'file' || !this.audioElement) return false;

        if (this.audioContext.state === 'suspended') {
          await this.audioContext.resume();
        }

        if (this.isPlaying) {
          this.audioElement.pause();
          this.isPlaying = false;
        } else {
          await this.audioElement.play();
          this.isPlaying = true;
        }

        return this.isPlaying;
      }

      getAmplitude() {
        if (this.sourceType === 'spotify' && this.spotifyPlayer) {
          return this.spotifyPlayer.getAmplitude();
        }
        if (!this.isPlaying && this.sourceType === 'file') {
          return this.defaultAmplitude;
        }
        return this.currentAmplitude || this.defaultAmplitude;
      }

      getTimeDomainData() {
        if (!this.analyser || !this.timeDomainData) return null;
        if (!this.isPlaying && this.sourceType === 'file') return null;

        this.analyser.getByteTimeDomainData(this.timeDomainData);
        return this.timeDomainData; // Uint8Array, values 0-255, 128 = silence
      }

      dispose() {
        this.disconnectSource();
        if (this.audioContext) {
          this.audioContext.close();
        }
      }
    }

    // =====================================================
    // Spotify PKCE Authentication Helpers
    // =====================================================
    function generateRandomString(length) {
      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const values = crypto.getRandomValues(new Uint8Array(length));
      return values.reduce((acc, x) => acc + possible[x % possible.length], '');
    }

    async function sha256(plain) {
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return window.crypto.subtle.digest('SHA-256', data);
    }

    function base64urlencode(a) {
      return btoa(String.fromCharCode.apply(null, new Uint8Array(a)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    async function generateCodeChallenge(verifier) {
      const hashed = await sha256(verifier);
      return base64urlencode(hashed);
    }

    // =====================================================
    // Spotify Token Management
    // =====================================================
    const SPOTIFY_TOKEN_KEY = 'spotify_access_token';
    const SPOTIFY_REFRESH_KEY = 'spotify_refresh_token';
    const SPOTIFY_EXPIRY_KEY = 'spotify_token_expiry';
    const SPOTIFY_VERIFIER_KEY = 'spotify_code_verifier';

    function getStoredToken() {
      const token = localStorage.getItem(SPOTIFY_TOKEN_KEY);
      const expiry = localStorage.getItem(SPOTIFY_EXPIRY_KEY);
      if (token && expiry && Date.now() < parseInt(expiry)) {
        return token;
      }
      return null;
    }

    function storeToken(accessToken, expiresIn, refreshToken) {
      localStorage.setItem(SPOTIFY_TOKEN_KEY, accessToken);
      localStorage.setItem(SPOTIFY_EXPIRY_KEY, Date.now() + (expiresIn * 1000));
      if (refreshToken) {
        localStorage.setItem(SPOTIFY_REFRESH_KEY, refreshToken);
      }
    }

    function clearTokens() {
      localStorage.removeItem(SPOTIFY_TOKEN_KEY);
      localStorage.removeItem(SPOTIFY_REFRESH_KEY);
      localStorage.removeItem(SPOTIFY_EXPIRY_KEY);
      localStorage.removeItem(SPOTIFY_VERIFIER_KEY);
    }

    async function initiateSpotifyLogin() {
      const codeVerifier = generateRandomString(64);
      localStorage.setItem(SPOTIFY_VERIFIER_KEY, codeVerifier);
      const codeChallenge = await generateCodeChallenge(codeVerifier);
      const params = new URLSearchParams({
        client_id: SPOTIFY_CONFIG.clientId,
        response_type: 'code',
        redirect_uri: SPOTIFY_CONFIG.redirectUri,
        code_challenge_method: 'S256',
        code_challenge: codeChallenge,
        scope: SPOTIFY_CONFIG.scopes.join(' ')
      });
      window.location.href = `https://accounts.spotify.com/authorize?${params.toString()}`;
    }

    async function exchangeCodeForToken(code) {
      const codeVerifier = localStorage.getItem(SPOTIFY_VERIFIER_KEY);
      const response = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          client_id: SPOTIFY_CONFIG.clientId,
          grant_type: 'authorization_code',
          code: code,
          redirect_uri: SPOTIFY_CONFIG.redirectUri,
          code_verifier: codeVerifier
        })
      });
      const data = await response.json();
      if (data.access_token) {
        storeToken(data.access_token, data.expires_in, data.refresh_token);
        window.history.replaceState({}, document.title, SPOTIFY_CONFIG.redirectUri);
        return data.access_token;
      }
      throw new Error(data.error_description || 'Failed to exchange code for token');
    }

    async function refreshAccessToken() {
      const refreshToken = localStorage.getItem(SPOTIFY_REFRESH_KEY);
      if (!refreshToken) return null;
      try {
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            client_id: SPOTIFY_CONFIG.clientId,
            grant_type: 'refresh_token',
            refresh_token: refreshToken
          })
        });
        const data = await response.json();
        if (data.access_token) {
          storeToken(data.access_token, data.expires_in, data.refresh_token);
          return data.access_token;
        }
      } catch (e) {
        console.error('Token refresh failed:', e);
      }
      clearTokens();
      return null;
    }

    // =====================================================
    // Spotify Audio Analysis (for beat-synced visualization)
    // =====================================================
    class SpotifyAnalysis {
      constructor() {
        this.trackAnalysis = null;
        this.audioFeatures = null;
        this.beats = [];
        this.currentBeatIndex = 0;
        this.currentAmplitude = 0;
        this.accessToken = null;
      }

      async loadTrackAnalysis(accessToken, trackId) {
        this.accessToken = accessToken;
        try {
          const [analysisRes, featuresRes] = await Promise.all([
            fetch(`https://api.spotify.com/v1/audio-analysis/${trackId}`, {
              headers: { 'Authorization': `Bearer ${accessToken}` }
            }),
            fetch(`https://api.spotify.com/v1/audio-features/${trackId}`, {
              headers: { 'Authorization': `Bearer ${accessToken}` }
            })
          ]);

          if (analysisRes.ok) {
            this.trackAnalysis = await analysisRes.json();
            this.beats = this.trackAnalysis.beats || [];
            this.currentBeatIndex = 0;
          }
          if (featuresRes.ok) {
            this.audioFeatures = await featuresRes.json();
          }
        } catch (e) {
          console.error('Failed to load track analysis:', e);
        }
      }

      updateAmplitude(positionMs, isPlaying) {
        if (!isPlaying || !this.beats.length) {
          this.currentAmplitude *= 0.9;
          return this.currentAmplitude;
        }

        const positionSec = positionMs / 1000;

        // Find current beat
        while (this.currentBeatIndex < this.beats.length - 1 &&
               this.beats[this.currentBeatIndex + 1].start <= positionSec) {
          this.currentBeatIndex++;
        }

        // Reset if we went backwards (seek)
        if (this.currentBeatIndex > 0 && this.beats[this.currentBeatIndex].start > positionSec) {
          this.currentBeatIndex = this.beats.findIndex(b => b.start > positionSec) - 1;
          if (this.currentBeatIndex < 0) this.currentBeatIndex = 0;
        }

        const beat = this.beats[this.currentBeatIndex];
        if (!beat) return this.currentAmplitude;

        const beatProgress = (positionSec - beat.start) / beat.duration;
        const beatConfidence = beat.confidence || 0.5;

        // Create amplitude pulse on beat
        if (beatProgress < 0.1) {
          // Attack phase
          this.currentAmplitude = Math.min(1, this.currentAmplitude + beatConfidence * 0.8);
        } else {
          // Decay phase
          const decayRate = 0.85 + (this.audioFeatures?.energy || 0.5) * 0.1;
          this.currentAmplitude *= decayRate;
        }

        return Math.min(Math.max(this.currentAmplitude, 0), 1);
      }

      reset() {
        this.trackAnalysis = null;
        this.audioFeatures = null;
        this.beats = [];
        this.currentBeatIndex = 0;
        this.currentAmplitude = 0;
      }
    }

    // =====================================================
    // SpotifyPlayer Class
    // =====================================================
    class SpotifyPlayer {
      constructor() {
        this.player = null;
        this.deviceId = null;
        this.isReady = false;
        this.isPlaying = false;
        this.currentTrack = null;
        this.positionMs = 0;
        this.onStateChange = null;
        this.analysis = new SpotifyAnalysis();
        this.accessToken = null;
        this.positionUpdateInterval = null;
      }

      async initialize(accessToken) {
        this.accessToken = accessToken;

        return new Promise((resolve, reject) => {
          const initPlayer = () => {
            this.player = new Spotify.Player({
              name: 'Pattern Effect Tool',
              getOAuthToken: cb => { cb(accessToken); },
              volume: 0.5
            });

            this.player.addListener('initialization_error', ({ message }) => {
              console.error('Spotify init error:', message);
              reject(new Error(message));
            });

            this.player.addListener('authentication_error', ({ message }) => {
              console.error('Spotify auth error:', message);
              clearTokens();
              reject(new Error(message));
            });

            this.player.addListener('account_error', ({ message }) => {
              console.error('Spotify account error:', message);
              reject(new Error('Spotify Premium required for playback'));
            });

            this.player.addListener('playback_error', ({ message }) => {
              console.error('Spotify playback error:', message);
            });

            this.player.addListener('ready', ({ device_id }) => {
              console.log('Spotify player ready:', device_id);
              this.deviceId = device_id;
              this.isReady = true;
              this.startPositionTracking();
              resolve(device_id);
            });

            this.player.addListener('not_ready', ({ device_id }) => {
              console.log('Device offline:', device_id);
              this.isReady = false;
            });

            this.player.addListener('player_state_changed', async (state) => {
              if (!state) return;

              this.isPlaying = !state.paused;
              this.positionMs = state.position;

              const track = state.track_window?.current_track;
              if (track && (!this.currentTrack || this.currentTrack.id !== track.id)) {
                this.currentTrack = track;
                await this.analysis.loadTrackAnalysis(this.accessToken, track.id);
              }

              if (this.onStateChange) {
                this.onStateChange(state);
              }
            });

            this.player.connect();
          };

          if (window.Spotify) {
            initPlayer();
          } else {
            window.onSpotifyWebPlaybackSDKReady = initPlayer;
          }
        });
      }

      startPositionTracking() {
        if (this.positionUpdateInterval) return;
        this.positionUpdateInterval = setInterval(() => {
          if (this.isPlaying) {
            this.positionMs += 50;
          }
        }, 50);
      }

      async transferPlayback() {
        await fetch('https://api.spotify.com/v1/me/player', {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${this.accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            device_ids: [this.deviceId],
            play: false
          })
        });
      }

      async togglePlay() {
        if (!this.player) return false;
        await this.player.togglePlay();
        return !this.isPlaying;
      }

      getAmplitude() {
        return this.analysis.updateAmplitude(this.positionMs, this.isPlaying);
      }

      disconnect() {
        if (this.positionUpdateInterval) {
          clearInterval(this.positionUpdateInterval);
          this.positionUpdateInterval = null;
        }
        if (this.player) {
          this.player.disconnect();
          this.player = null;
        }
        this.analysis.reset();
        this.isReady = false;
        this.isPlaying = false;
        this.deviceId = null;
        this.currentTrack = null;
      }
    }

    // =====================================================
    // Vertex Shader (with ripple/waveform displacement)
    // =====================================================
    const vertexShaderSource = `
      #define PI 3.14159265359

      varying vec2 vUv;
      varying float vRipple;

      uniform float uTime;
      uniform float uAmplitude;
      uniform float uRippleFreq;
      uniform float uRippleProgress;
      uniform float uHoverProgress;
      uniform int uPatternType;      // 0 = ripple, 1 = waveform
      uniform float uWaveformScale;  // Scale factor for waveform displacement
      uniform int uWaveformDir;      // 0 = horizontal (X displacement), 1 = vertical (Y displacement)
      uniform float uEdgeDamping;    // 1.0 = horizontal edge damping, 0.0 = corner pinning

      attribute float displacement;  // Per-vertex displacement for waveform

      void main() {
        vec3 pos = position;
        float effectDisplacement = 0.0;

        // Corner pinning mask: smooth falloff from 1.0 at center to 0.0 at corners
        float cornerDist = min(
          min(distance(uv, vec2(0.0, 0.0)), distance(uv, vec2(1.0, 0.0))),
          min(distance(uv, vec2(0.0, 1.0)), distance(uv, vec2(1.0, 1.0)))
        );
        float cornerMask = smoothstep(0.0, 0.15, cornerDist);

        // Horizontal edge damping mask: smooth gradient to 0 at left/right edges, free at top/bottom
        float edgeMask = smoothstep(0.0, 0.15, uv.x) * smoothstep(0.0, 0.15, 1.0 - uv.x);

        if (uPatternType == 0) {
          // RIPPLE: Radial from center
          float dist = distance(uv, vec2(0.5, 0.5));
          float decay = clamp(dist, 8.0, 10.0);
          effectDisplacement = sin(-PI * uRippleFreq * dist + uTime) * (uAmplitude / decay);
          effectDisplacement *= uRippleProgress * uHoverProgress;

          // Apply edge damping or corner pinning based on toggle
          if (uEdgeDamping > 0.5) {
            effectDisplacement *= edgeMask;
          } else {
            effectDisplacement *= cornerMask;
          }
        } else {
          // WAVEFORM: Use per-vertex displacement attribute
          effectDisplacement = displacement * uWaveformScale * uHoverProgress;

          // Waveform always uses corner pinning
          effectDisplacement *= cornerMask;
        }

        // Displace position based on pattern type and direction
        if (uPatternType == 0) {
          // RIPPLE: Y displacement (vertical warping)
          pos.y += effectDisplacement;
        } else {
          // WAVEFORM: displacement direction based on scroll direction
          if (uWaveformDir == 0) {
            // Horizontal scroll: X displacement (makes left/right edges peel)
            pos.x += effectDisplacement;
          } else {
            // Vertical scroll: Y displacement (makes top/bottom edges peel)
            pos.y += effectDisplacement;
          }
        }

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        vUv = uv;
        vRipple = effectDisplacement;
      }
    `;

    // =====================================================
    // Fragment Shader (color processing + ripple brightness)
    // =====================================================
    const fragmentShaderSource = `
      precision highp float;

      varying vec2 vUv;
      varying float vRipple;

      uniform sampler2D uTexture;
      uniform float uTime;
      uniform float uPaletteTime;
      uniform float uSpeed;
      uniform float uFrequency;
      uniform float uIntensity;
      uniform float uStrength;
      uniform vec2 uResolution;
      uniform float uImageAspect;
      uniform float uCanvasAspect;
      uniform float uHueStart;
      uniform float uHueRange;
      uniform float uRippleProgress;
      uniform bool uPaletteEnabled;

      // Grain uniforms
      uniform bool uGrainEnabled;
      uniform float uGrainIntensity;
      uniform float uGrainScale;
      uniform bool uGrainAnimated;
      uniform float uGrainSpeed;

      // Post-processing uniforms
      uniform bool uBloomEnabled;
      uniform float uBloomIntensity;
      uniform float uBloomThreshold;
      uniform bool uBlurEnabled;
      uniform float uBlurStrength;

      // Hover mode uniform
      uniform float uHoverProgress; // 0 = no effects, 1 = full effects

      // =====================================================
      // Simplex Noise (webgl-noise by Ashima Arts, MIT License)
      // =====================================================
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

      float snoise(vec2 v) {
        const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                           -0.577350269189626, 0.024390243902439);
        vec2 i  = floor(v + dot(v, C.yy));
        vec2 x0 = v - i + dot(i, C.xx);
        vec2 i1;
        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
        i = mod289(i);
        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                                + i.x + vec3(0.0, i1.x, 1.0));
        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                                dot(x12.zw,x12.zw)), 0.0);
        m = m*m;
        m = m*m;
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
        vec3 g;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
      }

      // Screen blend mode
      vec3 screenBlend(vec3 base, vec3 blend) {
        return 1.0 - (1.0 - base) * (1.0 - blend);
      }

      // Luminance calculation
      float luminance(vec3 color) {
        return dot(color, vec3(0.299, 0.587, 0.114));
      }

      // 9-point Gaussian blur
      vec4 blur9(sampler2D image, vec2 uv, vec2 texelSize, float strength) {
        vec4 color = vec4(0.0);
        vec2 off = texelSize * strength;

        color += texture2D(image, uv + off * vec2(-1.0,  1.0)) * 0.0625;
        color += texture2D(image, uv + off * vec2( 0.0,  1.0)) * 0.125;
        color += texture2D(image, uv + off * vec2( 1.0,  1.0)) * 0.0625;
        color += texture2D(image, uv + off * vec2(-1.0,  0.0)) * 0.125;
        color += texture2D(image, uv)                          * 0.25;
        color += texture2D(image, uv + off * vec2( 1.0,  0.0)) * 0.125;
        color += texture2D(image, uv + off * vec2(-1.0, -1.0)) * 0.0625;
        color += texture2D(image, uv + off * vec2( 0.0, -1.0)) * 0.125;
        color += texture2D(image, uv + off * vec2( 1.0, -1.0)) * 0.0625;

        return color;
      }

      // RGB to HSL conversion
      vec3 rgb2hsl(vec3 c) {
        float maxC = max(c.r, max(c.g, c.b));
        float minC = min(c.r, min(c.g, c.b));
        float l = (maxC + minC) * 0.5;

        if (maxC == minC) {
          return vec3(0.0, 0.0, l);
        }

        float d = maxC - minC;
        float s = l > 0.5 ? d / (2.0 - maxC - minC) : d / (maxC + minC);

        float h;
        if (maxC == c.r) {
          h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
        } else if (maxC == c.g) {
          h = (c.b - c.r) / d + 2.0;
        } else {
          h = (c.r - c.g) / d + 4.0;
        }
        h /= 6.0;

        return vec3(h, s, l);
      }

      // Hue to RGB helper
      float hue2rgb(float p, float q, float t) {
        if (t < 0.0) t += 1.0;
        if (t > 1.0) t -= 1.0;
        if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
        if (t < 1.0/2.0) return q;
        if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
        return p;
      }

      // HSL to RGB conversion
      vec3 hsl2rgb(vec3 hsl) {
        float h = hsl.x;
        float s = hsl.y;
        float l = hsl.z;

        if (s == 0.0) {
          return vec3(l);
        }

        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
        float p = 2.0 * l - q;

        float r = hue2rgb(p, q, h + 1.0/3.0);
        float g = hue2rgb(p, q, h);
        float b = hue2rgb(p, q, h - 1.0/3.0);

        return vec3(r, g, b);
      }

      void main() {
        vec2 uv = vUv;

        // Apply grain UV displacement (pre-texture sampling)
        if (uGrainEnabled) {
          // Scale controls grain size (higher = finer grain)
          vec2 noiseCoord = gl_FragCoord.xy / uGrainScale;

          // Add time offset for animation if enabled
          if (uGrainAnimated) {
            noiseCoord += uTime * uGrainSpeed;
          }

          // Generate noise and apply displacement (scaled by hover progress)
          float noise = snoise(noiseCoord);
          float grainAmount = uGrainIntensity * uHoverProgress;
          uv.x += noise * grainAmount;
          uv.y += noise * grainAmount;
        }

        vec4 texColor = texture2D(uTexture, uv);
        vec3 finalColor;

        if (uPaletteEnabled) {
          // Convert to HSL
          vec3 hsl = rgb2hsl(texColor.rgb);
          float luma = hsl.z;

          // Time-based animation (uses separate palette time)
          float timeOffset = uPaletteTime * uSpeed * 0.02;
          float lumaPosition = luma * uIntensity * 0.2;
          float hue = uHueStart + fract(lumaPosition + timeOffset) * uHueRange;
          hsl.x = fract(hue);

          // Saturation boost
          hsl.y = min(1.0, hsl.y + uStrength * 0.15);

          // Luminance adjustment
          hsl.z = hsl.z * (0.8 + uFrequency * 0.05) + 0.1;
          hsl.z = clamp(hsl.z, 0.0, 1.0);

          // Convert back to RGB and mix with original based on hover progress
          vec3 paletteColor = hsl2rgb(hsl);
          finalColor = mix(texColor.rgb, paletteColor, uHoverProgress);
        } else {
          // No palette - use original colors
          finalColor = texColor.rgb;
        }

        // Add ripple brightness variation
        finalColor += vRipple * 2.0 * uRippleProgress;

        // Apply blur effect
        if (uBlurEnabled) {
          vec2 texelSize = 1.0 / uResolution;
          vec4 blurredColor = blur9(uTexture, uv, texelSize, uBlurStrength * 2.0);

          vec3 processedBlur;
          if (uPaletteEnabled) {
            // Apply palette color processing to blurred samples
            vec3 blurHsl = rgb2hsl(blurredColor.rgb);
            float blurLuma = blurHsl.z;
            float blurTimeOffset = uPaletteTime * uSpeed * 0.02;
            float blurLumaPosition = blurLuma * uIntensity * 0.2;
            float blurHue = uHueStart + fract(blurLumaPosition + blurTimeOffset) * uHueRange;
            blurHsl.x = fract(blurHue);
            blurHsl.y = min(1.0, blurHsl.y + uStrength * 0.15);
            blurHsl.z = blurHsl.z * (0.8 + uFrequency * 0.05) + 0.1;
            blurHsl.z = clamp(blurHsl.z, 0.0, 1.0);
            processedBlur = hsl2rgb(blurHsl);
          } else {
            // Use original blurred colors without palette processing
            processedBlur = blurredColor.rgb;
          }

          finalColor = mix(finalColor, processedBlur, uBlurStrength * 0.1 * uHoverProgress);
        }

        // Apply bloom effect
        if (uBloomEnabled) {
          float lum = luminance(finalColor);
          float threshold = uBloomThreshold * 0.1;
          float bloomMask = smoothstep(threshold, threshold + 0.1, lum);
          vec3 bloomColor = finalColor * bloomMask;

          vec2 texelSize = 1.0 / uResolution;
          vec3 bloomBlur = vec3(0.0);
          float blurRadius = uBloomIntensity * 0.5;

          for (float x = -2.0; x <= 2.0; x += 1.0) {
            for (float y = -2.0; y <= 2.0; y += 1.0) {
              vec2 offset = vec2(x, y) * texelSize * blurRadius;
              vec4 sampleColor = texture2D(uTexture, uv + offset);
              vec3 sampleHsl = rgb2hsl(sampleColor.rgb);
              float sampleLum = sampleHsl.z;
              if (sampleLum > threshold) {
                bloomBlur += sampleColor.rgb * (sampleLum - threshold);
              }
            }
          }
          bloomBlur /= 25.0;

          vec3 bloomProcessed = bloomBlur * (uBloomIntensity * 0.3 * uHoverProgress);
          finalColor = screenBlend(finalColor, bloomProcessed);
        }

        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

    // =====================================================
    // Wireframe Fragment Shader (dark grey)
    // =====================================================
    const wireframeFragmentShader = `
      precision highp float;

      void main() {
        gl_FragColor = vec4(0.3, 0.3, 0.3, 0.6);
      }
    `;

    // =====================================================
    // Three.js Setup
    // =====================================================
    const canvas = document.getElementById('glCanvas');

    // Create renderer
    const renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance'
    });
    renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Create scene
    const scene = new THREE.Scene();

    // Create orthographic camera (sized to viewport)
    const { innerWidth: width, innerHeight: height } = window;
    const camera = new THREE.OrthographicCamera(
      -width / 2, width / 2,
      height / 2, -height / 2,
      -1000, 1000
    );
    camera.position.z = 10;

    // Create geometry with high subdivision for smooth ripple
    const geometry = new THREE.PlaneGeometry(1, 1, 100, 100);

    // Initialize waveform displacement attribute (101x101 = 10201 vertices)
    const vertexCount = geometry.attributes.position.count;
    let waveformHistory = new Float32Array(vertexCount);
    geometry.setAttribute('displacement', new THREE.BufferAttribute(waveformHistory, 1));

    // Image display settings
    const maxImageWidth = 600;  // Max width like index8
    const imageAspectRatio = 4 / 3;  // Default aspect ratio

    // Create shader material
    let material;
    let mesh;
    let texture;

    // Wireframe overlay
    let wireframeMaterial;
    let wireframeMesh;
    let wireframeEnabled = false;
    let imageVisible = true;

    // State variables
    let speed = 0.5;
    let frequency = 4;
    let intensity = 2.5;
    let strength = 2.5;
    let imageLoaded = false;
    let imageAspect = 1;

    // Palette state (full spectrum: hueStart=0, hueRange=1)
    let paletteEnabled = true;
    const hueStart = 0.0;
    const hueRange = 1.0;

    // Pattern type state
    let patternType = 'ripple'; // 'ripple' or 'waveform'

    // Ripple state
    let rippleEnabled = true;
    let rippleFreq = 13.5;
    let rippleAmplitude = 0.05;
    let rippleSpeed = 0.05;
    let rippleTime = 0;
    let rippleEdgeDamping = false;

    // Waveform state
    let waveformAmplitude = 0.8;   // Height scale for waveform (higher peaks)
    let waveformScrollRate = 30;   // Milliseconds between each scroll step (~33 rows/sec)
    let lastScrollUpdate = 0;      // Timestamp of last scroll step
    let currentWaveData = null;    // Cached waveform data
    let waveformDirection = 'left-to-right'; // 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'

    // Transient detection state
    let previousRMS = 0;           // Previous frame's RMS level
    let transientThreshold = 0.26; // Sensitivity - maps from slider 50 (0.5 - 0.24)
    let transientCooldown = 150;   // Minimum ms between triggers
    let lastTransientTime = 0;     // Timestamp of last trigger

    // Palette time (independent of ripple)
    let paletteTime = 0;

    // Post-processing state
    let bloomEnabled = true;
    let bloomIntensity = 7.5;
    let bloomThreshold = 5;
    let blurEnabled = true;
    let blurStrength = 5;

    // Grain state
    let grainEnabled = true;
    let grainIntensity = 0.02;
    let grainScale = 2.5;
    let grainAnimated = true;
    let grainSpeed = 0.75;

    // Mode state
    let currentMode = 'edit'; // 'edit' or 'hover'
    let isHovering = false;
    let hoverProgress = 1; // 0 = no effects, 1 = full effects (start at 1 for edit mode)
    let volumeProgress = 1; // 0.05 = ducked, 1 = full volume (for hover mode audio ducking)

    // Audio analyzer
    const audioAnalyzer = new AudioAnalyzer({ bufferSize: 512 });
    const audioMultiplier = 0.3;
    const maxAmplitude = 0.35;

    // Default values for reset
    const defaults = {
      paletteEnabled: true, speed: 0.5, frequency: 4, intensity: 2.5, strength: 2.5,
      patternType: 'ripple',
      rippleEnabled: true, rippleFreq: 13.5, rippleAmplitude: 0.05, rippleSpeed: 0.05, rippleEdgeDamping: false,
      waveformAmplitude: 0.8, waveformSensitivity: 50, waveformDirection: 'left-to-right',
      imageVisible: true, wireframeEnabled: false,
      bloomEnabled: true, bloomIntensity: 7.5, bloomThreshold: 5,
      blurEnabled: true, blurStrength: 5,
      grainEnabled: true, grainIntensity: 0.02, grainScale: 2.5, grainAnimated: true, grainSpeed: 0.75
    };

    // Create material with uniforms
    function createMaterial(tex) {
      return new THREE.ShaderMaterial({
        vertexShader: vertexShaderSource,
        fragmentShader: fragmentShaderSource,
        uniforms: {
          uTexture: { value: tex },
          uTime: { value: 0 },
          uPaletteTime: { value: 0 },
          uSpeed: { value: speed },
          uFrequency: { value: frequency },
          uIntensity: { value: intensity },
          uStrength: { value: strength },
          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          uImageAspect: { value: imageAspect },
          uCanvasAspect: { value: window.innerWidth / window.innerHeight },
          uHueStart: { value: hueStart },
          uHueRange: { value: hueRange },
          uPaletteEnabled: { value: paletteEnabled },
          uRippleProgress: { value: 0 },
          uAmplitude: { value: rippleAmplitude },
          uRippleFreq: { value: rippleFreq },
          uBloomEnabled: { value: bloomEnabled },
          uBloomIntensity: { value: bloomIntensity },
          uBloomThreshold: { value: bloomThreshold },
          uBlurEnabled: { value: blurEnabled },
          uBlurStrength: { value: blurStrength },
          uGrainEnabled: { value: grainEnabled },
          uGrainIntensity: { value: grainIntensity },
          uGrainScale: { value: grainScale },
          uGrainAnimated: { value: grainAnimated },
          uGrainSpeed: { value: grainSpeed },
          uHoverProgress: { value: hoverProgress },
          uPatternType: { value: 0 },
          uWaveformScale: { value: waveformAmplitude },
          uWaveformDir: { value: 0 },
          uEdgeDamping: { value: 0.0 }
        }
      });
    }

    // Calculate mesh size based on image aspect and viewport
    function calculateMeshSize() {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Use max width but ensure it fits in viewport with some padding
      let meshWidth = Math.min(maxImageWidth, viewportWidth * 0.8);
      let meshHeight = meshWidth / imageAspect;

      // If height exceeds viewport, scale down
      if (meshHeight > viewportHeight * 0.8) {
        meshHeight = viewportHeight * 0.8;
        meshWidth = meshHeight * imageAspect;
      }

      return { width: meshWidth, height: meshHeight };
    }

    // Create wireframe material
    function createWireframeMaterial() {
      return new THREE.ShaderMaterial({
        vertexShader: vertexShaderSource,
        fragmentShader: wireframeFragmentShader,
        wireframe: true,
        transparent: true,
        depthTest: false,
        uniforms: {
          uTime: { value: 0 },
          uAmplitude: { value: rippleAmplitude },
          uRippleFreq: { value: rippleFreq },
          uRippleProgress: { value: 0 },
          uHoverProgress: { value: hoverProgress },
          uPatternType: { value: 0 },
          uWaveformScale: { value: waveformAmplitude },
          uWaveformDir: { value: 0 },
          uEdgeDamping: { value: 0.0 }
        }
      });
    }

    // Load image
    function loadImage(src) {
      const loader = new THREE.TextureLoader();
      loader.load(src, (tex) => {
        texture = tex;
        imageAspect = tex.image.width / tex.image.height;

        if (mesh) {
          scene.remove(mesh);
          material.dispose();
        }

        if (wireframeMesh) {
          scene.remove(wireframeMesh);
          wireframeMaterial.dispose();
        }

        material = createMaterial(texture);
        mesh = new THREE.Mesh(geometry, material);

        // Create wireframe mesh
        wireframeMaterial = createWireframeMaterial();
        wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
        wireframeMesh.visible = wireframeEnabled;

        // Scale mesh to image size
        const size = calculateMeshSize();
        mesh.scale.set(size.width, size.height, 1);
        wireframeMesh.scale.set(size.width, size.height, 1);

        scene.add(mesh);
        scene.add(wireframeMesh);

        imageLoaded = true;
      });
    }

    // Load default image
    function loadDefaultImage() {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = function() {
        loadImage(img.src);
      };
      img.onerror = function() {
        // Fallback gradient (4:3 aspect ratio)
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 800;
        tempCanvas.height = 600;
        const ctx = tempCanvas.getContext('2d');
        const gradient = ctx.createRadialGradient(400, 300, 50, 400, 300, 400);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.5, '#666666');
        gradient.addColorStop(1, '#222222');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 800, 600);
        loadImage(tempCanvas.toDataURL());
      };
      img.src = 'statue.jpg';
    }

    // Resize handler
    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      renderer.setSize(w, h);

      // Update camera
      camera.left = -w / 2;
      camera.right = w / 2;
      camera.top = h / 2;
      camera.bottom = -h / 2;
      camera.updateProjectionMatrix();

      // Update mesh size
      if (mesh) {
        const size = calculateMeshSize();
        mesh.scale.set(size.width, size.height, 1);
        if (wireframeMesh) {
          wireframeMesh.scale.set(size.width, size.height, 1);
        }
      }

      if (material) {
        material.uniforms.uResolution.value.set(w, h);
        material.uniforms.uCanvasAspect.value = w / h;
      }

      // Update text stack position if in hover mode
      if (currentMode === 'hover') {
        const textStackEl = document.getElementById('textStack');
        if (textStackEl) {
          const meshSize = calculateMeshSize();
          const meshBottom = (h + meshSize.height) / 2;
          const meshLeft = (w - meshSize.width) / 2;
          textStackEl.style.top = (meshBottom + 20) + 'px';
          textStackEl.style.left = meshLeft + 'px';
          textStackEl.style.width = meshSize.width + 'px';
        }
      }
    }

    window.addEventListener('resize', resize);

    // Waveform displacement buffer management - supports horizontal and vertical scrolling
    function updateWaveformDisplacement(timeDomainData, fadeMultiplier = 1) {
      if (!waveformHistory || !mesh || patternType !== 'waveform') return;
      if (!timeDomainData) return;

      const cols = 101;  // Vertices per row (100 segments + 1)
      const rows = 101;  // Total rows
      const samples = timeDomainData.length; // 256 samples

      // Determine if horizontal or vertical
      const isHorizontal = (waveformDirection === 'left-to-right' || waveformDirection === 'right-to-left');
      const waveSize = isHorizontal ? rows : cols;

      // Sample the raw waveform
      let wave = new Float32Array(waveSize);
      for (let i = 0; i < waveSize; i++) {
        const sampleIdx = Math.floor((i / (waveSize - 1)) * (samples - 1));
        wave[i] = (timeDomainData[sampleIdx] - 128) / 128;
      }

      // Apply 5-point smoothing, multiple passes
      const smoothPasses = 3;
      let temp = new Float32Array(waveSize);
      for (let pass = 0; pass < smoothPasses; pass++) {
        for (let i = 0; i < waveSize; i++) {
          const i2 = Math.max(0, i - 2);
          const i1 = Math.max(0, i - 1);
          const i3 = Math.min(waveSize - 1, i + 1);
          const i4 = Math.min(waveSize - 1, i + 2);
          temp[i] = (wave[i2] + wave[i1] + wave[i] + wave[i3] + wave[i4]) / 5;
        }
        const swap = wave;
        wave = temp;
        temp = swap;
      }

      if (waveformDirection === 'left-to-right') {
        // Shift columns right, write to left
        for (let z = 0; z < rows; z++) {
          const rowStart = z * cols;
          for (let x = cols - 1; x > 0; x--) {
            waveformHistory[rowStart + x] = waveformHistory[rowStart + x - 1];
          }
        }
        for (let z = 0; z < rows; z++) {
          waveformHistory[z * cols] = wave[z] * waveformAmplitude * fadeMultiplier;
        }
      } else if (waveformDirection === 'right-to-left') {
        // Shift columns left, write to right
        for (let z = 0; z < rows; z++) {
          const rowStart = z * cols;
          for (let x = 0; x < cols - 1; x++) {
            waveformHistory[rowStart + x] = waveformHistory[rowStart + x + 1];
          }
        }
        for (let z = 0; z < rows; z++) {
          waveformHistory[z * cols + cols - 1] = wave[z] * waveformAmplitude * fadeMultiplier;
        }
      } else if (waveformDirection === 'top-to-bottom') {
        // Shift rows down, write to top
        waveformHistory.copyWithin(cols, 0);
        for (let x = 0; x < cols; x++) {
          waveformHistory[x] = wave[x] * waveformAmplitude * fadeMultiplier;
        }
      } else {
        // bottom-to-top: Shift rows up, write to bottom
        waveformHistory.copyWithin(0, cols);
        const startIdx = (rows - 1) * cols;
        for (let x = 0; x < cols; x++) {
          waveformHistory[startIdx + x] = wave[x] * waveformAmplitude * fadeMultiplier;
        }
      }

      // Update the geometry attribute
      geometry.attributes.displacement.needsUpdate = true;
    }

    // Shift waveform without adding new data (for continuous scrolling)
    function shiftWaveformOnly() {
      if (!waveformHistory || !mesh || patternType !== 'waveform') return;

      const cols = 101;
      const rows = 101;

      if (waveformDirection === 'left-to-right') {
        // Shift columns right, zero left
        for (let z = 0; z < rows; z++) {
          const rowStart = z * cols;
          for (let x = cols - 1; x > 0; x--) {
            waveformHistory[rowStart + x] = waveformHistory[rowStart + x - 1];
          }
          waveformHistory[rowStart] = 0;
        }
      } else if (waveformDirection === 'right-to-left') {
        // Shift columns left, zero right
        for (let z = 0; z < rows; z++) {
          const rowStart = z * cols;
          for (let x = 0; x < cols - 1; x++) {
            waveformHistory[rowStart + x] = waveformHistory[rowStart + x + 1];
          }
          waveformHistory[rowStart + cols - 1] = 0;
        }
      } else if (waveformDirection === 'top-to-bottom') {
        // Shift rows down, zero top
        waveformHistory.copyWithin(cols, 0);
        for (let x = 0; x < cols; x++) {
          waveformHistory[x] = 0;
        }
      } else {
        // bottom-to-top: Shift rows up, zero bottom
        waveformHistory.copyWithin(0, cols);
        const startIdx = (rows - 1) * cols;
        for (let x = 0; x < cols; x++) {
          waveformHistory[startIdx + x] = 0;
        }
      }

      geometry.attributes.displacement.needsUpdate = true;
    }

    // Apply 3x3 box blur smoothing to waveform buffer (for smooth terrain)
    function smoothWaveformBuffer() {
      if (!waveformHistory) return;

      const cols = 101;
      const rows = 101;
      const temp = new Float32Array(waveformHistory.length);

      // 3x3 box blur (skip edges to preserve fresh wave data at left column)
      for (let z = 1; z < rows - 1; z++) {
        for (let x = 1; x < cols - 1; x++) {
          const i = z * cols + x;
          temp[i] = (
            waveformHistory[i - cols - 1] + waveformHistory[i - cols] + waveformHistory[i - cols + 1] +
            waveformHistory[i - 1] + waveformHistory[i] + waveformHistory[i + 1] +
            waveformHistory[i + cols - 1] + waveformHistory[i + cols] + waveformHistory[i + cols + 1]
          ) / 9;
        }
      }

      // Copy smoothed values back (preserve edges)
      for (let z = 1; z < rows - 1; z++) {
        for (let x = 1; x < cols - 1; x++) {
          const i = z * cols + x;
          waveformHistory[i] = temp[i];
        }
      }

      // Zero edges perpendicular to scroll direction
      const isHorizontal = (waveformDirection === 'left-to-right' || waveformDirection === 'right-to-left');
      if (isHorizontal) {
        // Horizontal: zero top/bottom rows, left/right edges show waves
        for (let x = 0; x < cols; x++) {
          waveformHistory[x] = 0;                       // Top row (z=0)
          waveformHistory[(rows - 1) * cols + x] = 0;  // Bottom row (z=100)
        }
      } else {
        // Vertical: zero left/right columns, top/bottom edges show waves
        for (let z = 0; z < rows; z++) {
          waveformHistory[z * cols] = 0;               // Left column (x=0)
          waveformHistory[z * cols + cols - 1] = 0;   // Right column (x=100)
        }
      }
    }

    // Animation loop
    let startTime = Date.now();

    function render() {
      if (!imageLoaded || !material) {
        requestAnimationFrame(render);
        return;
      }

      const time = (Date.now() - startTime) / 1000;

      // Update ripple time
      rippleTime += rippleSpeed;

      // Update palette time (independent, fixed rate)
      paletteTime += 0.1;

      // Smooth hover transition (~0.6s)
      // Edit mode: always lerp toward 1
      // Hover mode: lerp toward 1 if hovering, 0 if not
      const target = (currentMode === 'edit') ? 1 : (isHovering ? 1 : 0);
      hoverProgress += (target - hoverProgress) * 0.08;

      // Audio volume ducking for hover mode (file playback only)
      // Edit mode: full volume (1.0)
      // Hover mode: ducked (0.05) when not hovering, full (1.0) when hovering
      const volumeTarget = (currentMode === 'edit') ? 1 : (isHovering ? 1 : 0.05);
      volumeProgress += (volumeTarget - volumeProgress) * 0.09;

      // Apply volume to audio element (file playback only, not mic)
      // Ease-in curve: starts slow, speeds up - softer at low volumes
      if (audioAnalyzer.audioElement && audioAnalyzer.sourceType === 'file') {
        const minVol = 0.05;
        // Normalize to 0-1 range
        const t = (volumeProgress - minVol) / (1 - minVol);
        // Apply ease-in (quadratic)
        const easedT = t * t;
        // Map back to volume range
        const easedVolume = minVol + easedT * (1 - minVol);
        audioAnalyzer.audioElement.volume = easedVolume;
      }

      // Get audio amplitude
      const audioLevel = audioAnalyzer.getAmplitude();
      const baseAmp = rippleAmplitude;
      const finalAmp = Math.min(baseAmp + (audioLevel * audioMultiplier), maxAmplitude);

      // Update waveform displacement buffer if in waveform mode
      // Transient detection: trigger on sudden amplitude increases
      if (patternType === 'waveform') {
        const now = Date.now();
        const shouldScroll = (now - lastScrollUpdate >= waveformScrollRate);

        if (shouldScroll) {
          // Get current audio level and calculate delta
          const currentRMS = audioAnalyzer.getAmplitude();
          const delta = currentRMS - previousRMS;
          previousRMS = currentRMS;

          // Detect transient (sudden amplitude increase)
          const cooldownElapsed = (now - lastTransientTime >= transientCooldown);
          const isTransient = delta > transientThreshold && cooldownElapsed;

          if (isTransient) {
            // Capture new waveform on transient
            currentWaveData = audioAnalyzer.getTimeDomainData();
            if (currentWaveData) {
              currentWaveData = new Uint8Array(currentWaveData);
            }
            lastTransientTime = now;
          }

          // Calculate fade (decay after transient) - 1 second decay
          const timeSinceTransient = now - lastTransientTime;
          const fadeMultiplier = Math.max(0, 1 - (timeSinceTransient / 1000));

          // Apply waveform with fade
          updateWaveformDisplacement(currentWaveData, fadeMultiplier);
          smoothWaveformBuffer();
          geometry.attributes.displacement.needsUpdate = true;

          lastScrollUpdate = now;
        }
      }

      // Update uniforms
      material.uniforms.uTime.value = rippleTime;
      material.uniforms.uPaletteTime.value = paletteTime;
      material.uniforms.uSpeed.value = speed;
      material.uniforms.uFrequency.value = frequency;
      material.uniforms.uIntensity.value = intensity;
      material.uniforms.uStrength.value = strength;
      material.uniforms.uHueStart.value = hueStart;
      material.uniforms.uHueRange.value = hueRange;
      material.uniforms.uPaletteEnabled.value = paletteEnabled;
      material.uniforms.uImageAspect.value = imageAspect;
      material.uniforms.uRippleProgress.value = rippleEnabled ? 1.0 : 0.0;
      material.uniforms.uAmplitude.value = finalAmp;
      material.uniforms.uRippleFreq.value = rippleFreq;
      material.uniforms.uBloomEnabled.value = bloomEnabled;
      material.uniforms.uBloomIntensity.value = bloomIntensity;
      material.uniforms.uBloomThreshold.value = bloomThreshold;
      material.uniforms.uBlurEnabled.value = blurEnabled;
      material.uniforms.uBlurStrength.value = blurStrength;
      material.uniforms.uGrainEnabled.value = grainEnabled;
      material.uniforms.uGrainIntensity.value = grainIntensity;
      material.uniforms.uGrainScale.value = grainScale;
      material.uniforms.uGrainAnimated.value = grainAnimated;
      material.uniforms.uGrainSpeed.value = grainSpeed;
      material.uniforms.uHoverProgress.value = hoverProgress;
      material.uniforms.uPatternType.value = patternType === 'ripple' ? 0 : 1;
      material.uniforms.uWaveformScale.value = waveformAmplitude;
      material.uniforms.uWaveformDir.value = (waveformDirection === 'left-to-right' || waveformDirection === 'right-to-left') ? 0 : 1;
      material.uniforms.uEdgeDamping.value = rippleEdgeDamping ? 1.0 : 0.0;

      // Sync wireframe uniforms
      if (wireframeMaterial) {
        wireframeMaterial.uniforms.uTime.value = rippleTime;
        wireframeMaterial.uniforms.uAmplitude.value = finalAmp;
        wireframeMaterial.uniforms.uRippleFreq.value = rippleFreq;
        wireframeMaterial.uniforms.uRippleProgress.value = rippleEnabled ? 1.0 : 0.0;
        wireframeMaterial.uniforms.uHoverProgress.value = hoverProgress;
        wireframeMaterial.uniforms.uPatternType.value = patternType === 'ripple' ? 0 : 1;
        wireframeMaterial.uniforms.uWaveformScale.value = waveformAmplitude;
        wireframeMaterial.uniforms.uWaveformDir.value = (waveformDirection === 'left-to-right' || waveformDirection === 'right-to-left') ? 0 : 1;
        wireframeMaterial.uniforms.uEdgeDamping.value = rippleEdgeDamping ? 1.0 : 0.0;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    // =====================================================
    // UI Event Handlers
    // =====================================================

    // Slider helpers
    function updateSliderFill(slider) {
      const min = parseFloat(slider.min);
      const max = parseFloat(slider.max);
      const val = parseFloat(slider.value);
      const percent = ((val - min) / (max - min)) * 100;
      slider.style.setProperty('--value-percent', percent + '%');
    }

    function setupSlider(id, updateFn, decimals = 2) {
      const slider = document.getElementById(id);
      const valueDisplay = document.getElementById(id + 'Value');

      updateSliderFill(slider);

      slider.addEventListener('input', () => {
        const val = parseFloat(slider.value);
        valueDisplay.textContent = val.toFixed(decimals);
        updateSliderFill(slider);
        updateFn(val);
      });
    }

    // Palette sliders
    setupSlider('speed', v => speed = v);
    setupSlider('frequency', v => frequency = v);
    setupSlider('intensity', v => intensity = v);
    setupSlider('strength', v => strength = v);

    // Ripple sliders
    setupSlider('rippleFreq', v => rippleFreq = v, 1);
    setupSlider('rippleAmplitude', v => rippleAmplitude = v);
    setupSlider('rippleSpeed', v => rippleSpeed = v);

    // Waveform sliders
    setupSlider('waveformAmplitude', v => waveformAmplitude = v);

    // Sensitivity slider (inverted: higher slider = lower threshold = more triggers)
    const sensitivitySlider = document.getElementById('waveformSensitivity');
    const sensitivityValue = document.getElementById('waveformSensitivityValue');
    if (sensitivitySlider) {
      sensitivitySlider.addEventListener('input', (e) => {
        const sliderValue = parseFloat(e.target.value);
        // Map 0-100 to 0.5-0.02 (inverted)
        transientThreshold = 0.5 - (sliderValue / 100) * 0.48;
        sensitivityValue.textContent = sliderValue;
        updateSliderFill(sensitivitySlider);
      });
      updateSliderFill(sensitivitySlider);
    }

    // Waveform direction toggle
    document.querySelectorAll('[data-waveform-dir]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelectorAll('[data-waveform-dir]').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        waveformDirection = e.target.dataset.waveformDir;
        // Clear buffer when direction changes
        if (waveformHistory) {
          waveformHistory.fill(0);
        }
      });
    });

    // Post-processing sliders
    setupSlider('bloomIntensity', v => bloomIntensity = v, 1);
    setupSlider('bloomThreshold', v => bloomThreshold = v, 1);
    setupSlider('blurStrength', v => blurStrength = v, 1);

    // Grain sliders
    setupSlider('grainIntensity', v => grainIntensity = v, 3);
    setupSlider('grainScale', v => grainScale = v, 3);
    setupSlider('grainSpeed', v => grainSpeed = v, 3);

    // Helper function to toggle pattern slider visibility
    function togglePatternSliders(type) {
      document.querySelectorAll('.ripple-slider').forEach(el => {
        el.style.display = type === 'ripple' ? '' : 'none';
      });
      document.querySelectorAll('.waveform-slider').forEach(el => {
        el.style.display = type === 'waveform' ? '' : 'none';
      });
    }

    // Effect toggles (pattern, palette, bloom, blur, wireframe)
    document.querySelectorAll('[data-effect]').forEach(option => {
      option.addEventListener('click', (e) => {
        // Stop propagation for header toggle buttons to prevent expand/collapse
        if (option.classList.contains('toggle-btn')) {
          e.stopPropagation();
        }
        const effectName = option.dataset.effect;

        if (effectName === 'pattern-ripple') {
          patternType = 'ripple';
          rippleEnabled = true;
          document.querySelector('[data-effect="pattern-ripple"]').classList.add('active');
          document.querySelector('[data-effect="pattern-waveform"]').classList.remove('active');
          togglePatternSliders('ripple');
        } else if (effectName === 'pattern-waveform') {
          patternType = 'waveform';
          rippleEnabled = true;
          document.querySelector('[data-effect="pattern-waveform"]').classList.add('active');
          document.querySelector('[data-effect="pattern-ripple"]').classList.remove('active');
          togglePatternSliders('waveform');
        } else if (effectName === 'palette') {
          paletteEnabled = !paletteEnabled;
          option.classList.toggle('active', paletteEnabled);
        } else if (effectName === 'bloom') {
          bloomEnabled = !bloomEnabled;
          option.classList.toggle('active', bloomEnabled);
        } else if (effectName === 'blur') {
          blurEnabled = !blurEnabled;
          option.classList.toggle('active', blurEnabled);
        } else if (effectName === 'image') {
          imageVisible = !imageVisible;
          option.classList.toggle('active', imageVisible);
          if (mesh) {
            mesh.visible = imageVisible;
          }
        } else if (effectName === 'wireframe') {
          wireframeEnabled = !wireframeEnabled;
          option.classList.toggle('active', wireframeEnabled);
          if (wireframeMesh) {
            wireframeMesh.visible = wireframeEnabled;
          }
        } else if (effectName === 'grain') {
          grainEnabled = !grainEnabled;
          option.classList.toggle('active', grainEnabled);
        } else if (effectName === 'grainAnimated') {
          grainAnimated = !grainAnimated;
          option.classList.toggle('active', grainAnimated);
        } else if (effectName === 'ripple-edge-damping') {
          rippleEdgeDamping = !rippleEdgeDamping;
          option.classList.toggle('active', rippleEdgeDamping);
        }
      });
    });

    // Text stack element
    const textStack = document.getElementById('textStack');

    // Update text stack position based on mesh bounds
    function updateTextStackPosition() {
      const meshSize = calculateMeshSize();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      const meshBottom = (viewportHeight + meshSize.height) / 2;
      const meshLeft = (viewportWidth - meshSize.width) / 2;

      textStack.style.top = (meshBottom + 20) + 'px';
      textStack.style.left = meshLeft + 'px';
      textStack.style.width = meshSize.width + 'px';
      textStack.style.transform = 'none';
    }

    // Mode toggle (edit/hover)
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const mode = btn.dataset.mode;
        if (mode === currentMode) return;

        currentMode = mode;
        document.querySelectorAll('.mode-btn').forEach(b =>
          b.classList.toggle('active', b.dataset.mode === mode)
        );

        // Toggle controls visibility with fade
        const controlsPanel = document.querySelector('.controls-panel');
        controlsPanel.classList.toggle('hidden', mode === 'hover');

        // Toggle text stack visibility with fade
        textStack.classList.toggle('visible', mode === 'hover');
        if (mode === 'hover') {
          updateTextStackPosition();
        }

        // Reset hover state when switching modes
        // (hoverProgress will smoothly transition in render loop)
        if (mode === 'hover') {
          isHovering = false;
        } else {
          // Reset cursor when leaving hover mode
          document.body.style.cursor = 'default';
        }
      });
    });

    // Mesh hover detection for hover mode
    // Check if mouse is within the mesh bounds + gap + text stack
    document.addEventListener('mousemove', (e) => {
      if (currentMode !== 'hover') return;

      // Get mesh screen bounds (mesh is centered in viewport)
      const meshSize = calculateMeshSize();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      const meshLeft = (viewportWidth - meshSize.width) / 2;
      const meshRight = (viewportWidth + meshSize.width) / 2;
      const meshTop = (viewportHeight - meshSize.height) / 2;

      // Extend bottom bound to include text stack
      const textStackRect = textStack.getBoundingClientRect();
      const bottomBound = textStackRect.bottom;

      // Check if mouse is within extended bounds (image + gap + text)
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      isHovering = mouseX >= meshLeft && mouseX <= meshRight &&
                   mouseY >= meshTop && mouseY <= bottomBound;

      // Change cursor to pointer when hovering over the content area
      document.body.style.cursor = isHovering ? 'pointer' : 'default';
    });

    // Also handle mouse leaving the window entirely
    document.addEventListener('mouseleave', () => {
      if (currentMode === 'hover') {
        isHovering = false;
      }
    });

    // Buttons
    document.getElementById('newImageBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      speed = defaults.speed;
      frequency = defaults.frequency;
      intensity = defaults.intensity;
      strength = defaults.strength;

      const speedSlider = document.getElementById('speed');
      const frequencySlider = document.getElementById('frequency');
      const intensitySlider = document.getElementById('intensity');
      const strengthSlider = document.getElementById('strength');

      speedSlider.value = speed;
      frequencySlider.value = frequency;
      intensitySlider.value = intensity;
      strengthSlider.value = strength;

      updateSliderFill(speedSlider);
      updateSliderFill(frequencySlider);
      updateSliderFill(intensitySlider);
      updateSliderFill(strengthSlider);

      document.getElementById('speedValue').textContent = speed.toFixed(2);
      document.getElementById('frequencyValue').textContent = frequency.toFixed(2);
      document.getElementById('intensityValue').textContent = intensity.toFixed(2);
      document.getElementById('strengthValue').textContent = strength.toFixed(2);

      // Reset palette
      paletteEnabled = defaults.paletteEnabled;

      // Reset pattern type
      patternType = defaults.patternType;

      // Reset ripple
      rippleEnabled = defaults.rippleEnabled;
      rippleFreq = defaults.rippleFreq;
      rippleAmplitude = defaults.rippleAmplitude;
      rippleSpeed = defaults.rippleSpeed;
      rippleEdgeDamping = defaults.rippleEdgeDamping;

      const rippleFreqSlider = document.getElementById('rippleFreq');
      const rippleAmplitudeSlider = document.getElementById('rippleAmplitude');
      const rippleSpeedSlider = document.getElementById('rippleSpeed');

      rippleFreqSlider.value = rippleFreq;
      rippleAmplitudeSlider.value = rippleAmplitude;
      rippleSpeedSlider.value = rippleSpeed;

      updateSliderFill(rippleFreqSlider);
      updateSliderFill(rippleAmplitudeSlider);
      updateSliderFill(rippleSpeedSlider);

      document.getElementById('rippleFreqValue').textContent = rippleFreq.toFixed(1);
      document.getElementById('rippleAmplitudeValue').textContent = rippleAmplitude.toFixed(2);
      document.getElementById('rippleSpeedValue').textContent = rippleSpeed.toFixed(2);

      // Reset waveform
      waveformAmplitude = defaults.waveformAmplitude;
      const sensitivityDefault = defaults.waveformSensitivity;
      // Map slider value to threshold (inverted)
      transientThreshold = 0.5 - (sensitivityDefault / 100) * 0.48;

      const waveformAmplitudeSlider = document.getElementById('waveformAmplitude');
      const waveformSensitivitySlider = document.getElementById('waveformSensitivity');

      waveformAmplitudeSlider.value = waveformAmplitude;
      waveformSensitivitySlider.value = sensitivityDefault;

      updateSliderFill(waveformAmplitudeSlider);
      updateSliderFill(waveformSensitivitySlider);

      document.getElementById('waveformAmplitudeValue').textContent = waveformAmplitude.toFixed(2);
      document.getElementById('waveformSensitivityValue').textContent = sensitivityDefault;

      // Reset waveform direction
      waveformDirection = defaults.waveformDirection;
      document.querySelectorAll('[data-waveform-dir]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.waveformDir === waveformDirection);
      });

      // Clear waveform history buffer
      if (waveformHistory) {
        waveformHistory.fill(0);
        geometry.attributes.displacement.needsUpdate = true;
      }

      // Reset pattern UI
      document.querySelector('[data-effect="pattern-ripple"]').classList.add('active');
      document.querySelector('[data-effect="pattern-waveform"]').classList.remove('active');
      document.querySelector('[data-effect="ripple-edge-damping"]').classList.toggle('active', defaults.rippleEdgeDamping);
      togglePatternSliders('ripple');

      // Reset image visibility
      imageVisible = defaults.imageVisible;
      if (mesh) {
        mesh.visible = imageVisible;
      }

      // Reset wireframe
      wireframeEnabled = defaults.wireframeEnabled;
      if (wireframeMesh) {
        wireframeMesh.visible = wireframeEnabled;
      }

      // Reset post-processing
      bloomEnabled = defaults.bloomEnabled;
      bloomIntensity = defaults.bloomIntensity;
      bloomThreshold = defaults.bloomThreshold;
      blurEnabled = defaults.blurEnabled;
      blurStrength = defaults.blurStrength;

      const bloomIntensitySlider = document.getElementById('bloomIntensity');
      const bloomThresholdSlider = document.getElementById('bloomThreshold');
      const blurStrengthSlider = document.getElementById('blurStrength');

      bloomIntensitySlider.value = bloomIntensity;
      bloomThresholdSlider.value = bloomThreshold;
      blurStrengthSlider.value = blurStrength;

      updateSliderFill(bloomIntensitySlider);
      updateSliderFill(bloomThresholdSlider);
      updateSliderFill(blurStrengthSlider);

      document.getElementById('bloomIntensityValue').textContent = bloomIntensity.toFixed(1);
      document.getElementById('bloomThresholdValue').textContent = bloomThreshold.toFixed(1);
      document.getElementById('blurStrengthValue').textContent = blurStrength.toFixed(1);

      // Reset grain
      grainEnabled = defaults.grainEnabled;
      grainIntensity = defaults.grainIntensity;
      grainScale = defaults.grainScale;
      grainAnimated = defaults.grainAnimated;
      grainSpeed = defaults.grainSpeed;

      const grainIntensitySlider = document.getElementById('grainIntensity');
      const grainScaleSlider = document.getElementById('grainScale');
      const grainSpeedSlider = document.getElementById('grainSpeed');

      grainIntensitySlider.value = grainIntensity;
      grainScaleSlider.value = grainScale;
      grainSpeedSlider.value = grainSpeed;

      updateSliderFill(grainIntensitySlider);
      updateSliderFill(grainScaleSlider);
      updateSliderFill(grainSpeedSlider);

      document.getElementById('grainIntensityValue').textContent = grainIntensity.toFixed(3);
      document.getElementById('grainScaleValue').textContent = grainScale.toFixed(3);
      document.getElementById('grainSpeedValue').textContent = grainSpeed.toFixed(3);

      // Reset effect toggle UI states
      document.querySelectorAll('[data-effect]').forEach(opt => {
        const effect = opt.dataset.effect;
        if (effect === 'palette') {
          opt.classList.toggle('active', defaults.paletteEnabled);
        } else if (effect === 'pattern-ripple') {
          opt.classList.toggle('active', defaults.patternType === 'ripple');
        } else if (effect === 'pattern-waveform') {
          opt.classList.toggle('active', defaults.patternType === 'waveform');
        } else if (effect === 'image') {
          opt.classList.toggle('active', defaults.imageVisible);
        } else if (effect === 'wireframe') {
          opt.classList.toggle('active', defaults.wireframeEnabled);
        } else if (effect === 'bloom') {
          opt.classList.toggle('active', defaults.bloomEnabled);
        } else if (effect === 'blur') {
          opt.classList.toggle('active', defaults.blurEnabled);
        } else if (effect === 'grain') {
          opt.classList.toggle('active', defaults.grainEnabled);
        } else if (effect === 'grainAnimated') {
          opt.classList.toggle('active', defaults.grainAnimated);
        }
      });
    });

    // File input
    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          loadImage(event.target.result);
        };
        reader.readAsDataURL(file);
      }
    });

    // Drag and drop
    const dropZone = document.getElementById('dropZone');

    document.body.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('active');
    });

    document.body.addEventListener('dragleave', (e) => {
      e.preventDefault();
      if (e.relatedTarget === null || !document.body.contains(e.relatedTarget)) {
        dropZone.classList.remove('active');
      }
    });

    document.body.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('active');

      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (event) => {
          loadImage(event.target.result);
        };
        reader.readAsDataURL(file);
      }
    });

    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropZone.classList.remove('active');
    });

    // Section expand/collapse
    document.querySelectorAll('.row-header').forEach(header => {
      header.addEventListener('click', () => {
        const section = header.closest('.section');
        const allRows = section.querySelectorAll('.section-content .row');
        const visibleRows = Array.from(allRows).filter(row => row.style.display !== 'none');
        const isCollapsing = !section.classList.contains('collapsed');
        const staggerDelay = 0.4;

        // Reset hidden rows to have no delay
        allRows.forEach(row => {
          if (row.style.display === 'none') {
            row.style.setProperty('--row-delay', '0s');
            const inner = row.querySelector('.row-inner');
            if (inner) inner.style.setProperty('--row-delay', '0s');
          }
        });

        if (isCollapsing) {
          visibleRows.forEach((row, index) => {
            const delay = (visibleRows.length - 1 - index) * staggerDelay;
            row.style.setProperty('--row-delay', `${delay}s`);
            const inner = row.querySelector('.row-inner');
            if (inner) inner.style.setProperty('--row-delay', `${delay}s`);
          });
          section.classList.add('collapsed');
        } else {
          visibleRows.forEach((row, index) => {
            const delay = index * staggerDelay;
            row.style.setProperty('--row-delay', `${delay}s`);
            const inner = row.querySelector('.row-inner');
            if (inner) inner.style.setProperty('--row-delay', `${delay}s`);
          });
          section.classList.remove('collapsed');
        }
      });
    });

    // =====================================================
    // Audio Controls
    // =====================================================
    const audioPlayToggle = document.getElementById('audio-play-toggle');
    const audioChooseFileBtn = document.getElementById('audioChooseFileBtn');
    const audioMicBtn = document.getElementById('audioMicBtn');
    const audioFileInput = document.getElementById('audioFileInput');
    const spotifyBtn = document.getElementById('spotifyBtn');
    const spotifyTrackInfo = document.getElementById('spotify-track-info');
    let spotifyPlayer = null;

    audioFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        await audioAnalyzer.init();
        const url = URL.createObjectURL(file);
        await audioAnalyzer.loadAudioFile(url);

        const isPlaying = await audioAnalyzer.togglePlay();
        audioPlayToggle.classList.toggle('active', isPlaying);
      }
    });

    audioPlayToggle.addEventListener('click', async () => {
      // Handle Spotify playback
      if (audioAnalyzer.sourceType === 'spotify' && spotifyPlayer?.isReady) {
        await spotifyPlayer.togglePlay();
        return;
      }

      await audioAnalyzer.init();

      if (!audioAnalyzer.audioElement?.src) {
        audioFileInput.click();
        return;
      }

      const isPlaying = await audioAnalyzer.togglePlay();
      audioPlayToggle.classList.toggle('active', isPlaying);
    });

    audioChooseFileBtn.addEventListener('click', () => {
      audioFileInput.click();
    });

    audioMicBtn.addEventListener('click', async () => {
      await audioAnalyzer.init();

      if (audioAnalyzer.sourceType === 'mic' && audioAnalyzer.isPlaying) {
        audioAnalyzer.disconnectSource();
        audioMicBtn.textContent = 'USE MIC';
        audioMicBtn.classList.remove('active');
        audioPlayToggle.classList.remove('active');
      } else {
        try {
          await audioAnalyzer.connectMicrophone();
          audioMicBtn.textContent = 'STOP MIC';
          audioMicBtn.classList.add('active');
          audioPlayToggle.classList.remove('active');
        } catch (e) {
          alert('Microphone access denied. Please allow microphone access.');
        }
      }
    });

    // =====================================================
    // Spotify Controls
    // =====================================================
    async function initializeSpotifyPlayer(accessToken) {
      spotifyPlayer = new SpotifyPlayer();

      try {
        await spotifyPlayer.initialize(accessToken);
        await spotifyPlayer.transferPlayback();
        audioAnalyzer.connectSpotify(spotifyPlayer);

        spotifyBtn.textContent = 'DISCONNECT';
        spotifyBtn.classList.remove('connecting');
        spotifyBtn.classList.add('active');

        // Deactivate other sources
        audioMicBtn.textContent = 'USE MIC';
        audioMicBtn.classList.remove('active');
        audioPlayToggle.classList.remove('active');

        // Update track info on state change
        spotifyPlayer.onStateChange = (state) => {
          if (state?.track_window?.current_track) {
            const track = state.track_window.current_track;
            spotifyTrackInfo.textContent = `${track.artists[0].name} - ${track.name}`;
            spotifyTrackInfo.classList.add('visible');
          }
          audioPlayToggle.classList.toggle('active', !state.paused);
          audioAnalyzer.isPlaying = !state.paused;
        };
      } catch (error) {
        console.error('Spotify player init failed:', error);
        spotifyBtn.textContent = 'SPOTIFY';
        spotifyBtn.classList.remove('connecting', 'active');

        if (error.message.includes('Premium')) {
          alert('Spotify Premium is required for playback.');
        } else {
          alert('Failed to initialize Spotify player: ' + error.message);
        }
      }
    }

    // Check for OAuth callback on page load
    (async function handleSpotifyCallback() {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');
      const error = urlParams.get('error');

      if (error) {
        console.error('Spotify auth error:', error);
        window.history.replaceState({}, document.title, SPOTIFY_CONFIG.redirectUri);
        return;
      }

      if (code) {
        try {
          spotifyBtn.classList.add('connecting');
          spotifyBtn.textContent = 'CONNECTING...';
          const accessToken = await exchangeCodeForToken(code);
          await initializeSpotifyPlayer(accessToken);
        } catch (error) {
          console.error('Spotify auth failed:', error);
          spotifyBtn.textContent = 'SPOTIFY';
          spotifyBtn.classList.remove('connecting');
          alert('Spotify authentication failed: ' + error.message);
        }
      }
    })();

    spotifyBtn.addEventListener('click', async () => {
      // If connected, disconnect
      if (spotifyPlayer?.isReady) {
        spotifyPlayer.disconnect();
        audioAnalyzer.disconnectSource();
        spotifyPlayer = null;

        spotifyBtn.textContent = 'SPOTIFY';
        spotifyBtn.classList.remove('active');
        audioPlayToggle.classList.remove('active');
        spotifyTrackInfo.classList.remove('visible');
        spotifyTrackInfo.textContent = '';
        return;
      }

      // Check for existing token
      let accessToken = getStoredToken();

      if (accessToken) {
        spotifyBtn.classList.add('connecting');
        spotifyBtn.textContent = 'CONNECTING...';

        try {
          await initializeSpotifyPlayer(accessToken);
        } catch (error) {
          // Token may be expired, try refresh
          accessToken = await refreshAccessToken();
          if (accessToken) {
            try {
              await initializeSpotifyPlayer(accessToken);
            } catch (e) {
              // Refresh didn't help, need re-auth
              await initiateSpotifyLogin();
            }
          } else {
            // No refresh token, need to re-authenticate
            await initiateSpotifyLogin();
          }
        }
      } else {
        // No token, start OAuth flow
        await initiateSpotifyLogin();
      }
    });

    // =====================================================
    // Start
    // =====================================================
    loadDefaultImage();
    render();
  </script>
</body>
</html>
