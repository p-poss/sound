<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pattern Effect Tool</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
  <script src="https://unpkg.com/meyda@5.2.1/dist/web/meyda.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #ffffff;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    #glCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .controls-panel {
      position: fixed;
      top: 30px;
      right: 30px;
      width: 400px;
      display: flex;
      flex-direction: column;
      gap: 1.5px;
    }

    .section {
      background: transparent;
    }

    .row {
      height: 54px;
      display: flex;
      align-items: center;
      padding: 0 20px;
      cursor: pointer;
      position: relative;
      transition: background 0.15s ease;
      background: rgba(0,0,0,0.12);
    }

    .row:hover {
      background: rgba(0,0,0,0.15);
    }

    .row-header {
      justify-content: space-between;
      background: rgba(38, 41, 47, 0.5);
      backdrop-filter: blur(20px);
    }

    .row-header .label {
      font-size: 13.5px;
      font-weight: 700;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
    }

    .row-header .arrow {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 5px solid #fff;
      transition: transform 0.4s ease;
    }

    .section.collapsed .row-header .arrow {
      transform: rotate(-90deg);
    }

    .section-content {
      display: flex;
      flex-direction: column;
    }

    .section-content .row {
      height: 54px;
      padding: 0;
      overflow: hidden;
      flex-shrink: 0;
      background: rgba(45, 48, 54, 0.5);
      backdrop-filter: blur(20px);
      transition: height 0.4s ease var(--row-delay, 0s);
      display: block;
    }

    .section-content .row-inner {
      height: 54px;
      display: flex;
      align-items: center;
      padding: 0 20px;
      transform: translateY(0);
      transition: transform 0.4s ease var(--row-delay, 0s);
    }

    .section-content .row-option .row-inner {
      justify-content: space-between;
      width: 100%;
    }

    .section-content .row-slider .row-inner {
      width: 100%;
    }

    .section-content .row:hover {
      background: rgba(0,0,0,0.15);
    }

    .section-content .row.row-slider,
    .section-content .row.row-option {
      background: rgba(50, 53, 58, 0.5);
    }

    .section-content .row.row-slider:hover,
    .section-content .row.row-option:hover {
      background: rgba(0,0,0,0.15);
    }

    .section.collapsed .section-content .row {
      height: 0;
    }

    .section.collapsed .section-content .row-inner {
      transform: translateY(-54px);
    }

    .row-option {
      justify-content: space-between;
    }

    .row-option .label {
      font-size: 13.5px;
      font-weight: 400;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
    }

    .row-option .check {
      opacity: 0;
      transition: opacity 0.15s ease;
    }

    .row-option.active .check {
      opacity: 1;
    }

    .check svg {
      width: 16px;
      height: 16px;
      color: #fff;
    }

    .row-option + .row-slider .row-inner,
    .row-slider + .row-slider .row-inner,
    .row-option + .row-option .row-inner {
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .row-slider .label {
      font-size: 13.5px;
      font-weight: 400;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
      flex-shrink: 0;
      width: 80px;
      margin-right: 40px;
    }

    .slider-wrapper {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      margin-right: 20px;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 2px;
      background: linear-gradient(to right, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.9) var(--value-percent, 50%), rgba(255,255,255,0.25) var(--value-percent, 50%), rgba(255,255,255,0.25) 100%);
      border-radius: 1px;
      outline: none;
      cursor: pointer;
      margin: 0;
      padding: 0;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 4.5px;
      height: 9px;
      background: #fff;
      border-radius: 1px;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 4.5px;
      height: 9px;
      background: #fff;
      border-radius: 1px;
      cursor: pointer;
      border: none;
    }

    input[type="range"]::-moz-range-progress {
      background: rgba(255,255,255,0.9);
      height: 2px;
    }

    .slider-value {
      padding: 4px;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: -0.25px;
      line-height: 1;
      font-variant-numeric: tabular-nums;
      color: #fff;
      text-align: center;
      flex-shrink: 0;
      background: rgba(0,0,0,0.25);
      border-radius: 3px;
    }

    .button-row {
      display: flex;
      gap: 1px;
    }

    .btn {
      flex: 1;
      height: 54px;
      font-size: 13.5px;
      font-weight: 700;
      letter-spacing: -0.25px;
      line-height: 1;
      cursor: pointer;
      transition: background 0.15s ease;
      background: rgba(38, 41, 47, 0.5);
      backdrop-filter: blur(20px);
      border: none;
      color: #fff;
      font-family: inherit;
    }

    .btn:hover {
      background: rgba(0,0,0,0.15);
    }

    .drop-zone {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 10;
    }

    .drop-zone.active {
      opacity: 1;
      pointer-events: auto;
    }

    .drop-zone-content {
      text-align: center;
      color: rgba(255,255,255,0.7);
    }

    .drop-zone-content svg {
      width: 48px;
      height: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    #fileInput {
      display: none;
    }

    /* Audio Controls */
    .audio-controls {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      background-color: rgba(38, 41, 47, 0.85);
      border-radius: 12px;
      padding: 8px 16px;
      z-index: 100;
      backdrop-filter: blur(20px);
    }

    .audio-controls__label {
      color: rgba(255,255,255,0.6);
      font-size: 12px;
      font-weight: 600;
      margin-right: 4px;
    }

    .audio-controls__btn {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-family: 'Inter', sans-serif;
      font-size: 13px;
      font-weight: 600;
      background-color: rgba(255,255,255,0.1);
      color: #fff;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }

    .audio-controls__btn:hover {
      background-color: rgba(255,255,255,0.15);
    }

    .audio-controls__btn:active {
      transform: scale(0.97);
    }

    .audio-controls__btn.active {
      background-color: #4CAF50;
    }

    .audio-controls__btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .audio-controls__btn--file {
      background-color: rgba(255,255,255,0.08);
      cursor: pointer;
    }

    .audio-controls__btn--file:hover {
      background-color: rgba(255,255,255,0.12);
    }

    .audio-controls__separator {
      width: 1px;
      height: 24px;
      background-color: rgba(255,255,255,0.2);
      margin: 0 4px;
    }

    .audio-controls__file-input {
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>

  <div class="drop-zone" id="dropZone">
    <div class="drop-zone-content">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
      </svg>
      <p>Drop image here</p>
    </div>
  </div>

  <div class="controls-panel">
    <div class="section">
      <div class="row row-header">
        <span class="label">RIPPLE</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option" data-effect="ripple">
          <div class="row-inner">
            <span class="label">ENABLED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-option active" data-effect="image">
          <div class="row-inner">
            <span class="label">IMAGE</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-option" data-effect="wireframe">
          <div class="row-inner">
            <span class="label">WIREFRAME</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">FREQUENCY</span>
            <div class="slider-wrapper">
              <input type="range" id="rippleFreq" min="1" max="20" step="0.1" value="8">
            </div>
            <span class="slider-value" id="rippleFreqValue">8.0</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">AMPLITUDE</span>
            <div class="slider-wrapper">
              <input type="range" id="rippleAmplitude" min="0.01" max="0.5" step="0.01" value="0.02">
            </div>
            <span class="slider-value" id="rippleAmplitudeValue">0.02</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">SPEED</span>
            <div class="slider-wrapper">
              <input type="range" id="rippleSpeed" min="0.01" max="0.20" step="0.01" value="0.1">
            </div>
            <span class="slider-value" id="rippleSpeedValue">0.10</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="row row-header">
        <span class="label">PALETTE</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option active" data-effect="palette">
          <div class="row-inner">
            <span class="label">ENABLED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">SPEED</span>
            <div class="slider-wrapper">
              <input type="range" id="speed" min="0" max="1" step="0.01" value="0.5">
            </div>
            <span class="slider-value" id="speedValue">0.50</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">FREQUENCY</span>
            <div class="slider-wrapper">
              <input type="range" id="frequency" min="0.5" max="10" step="0.01" value="4">
            </div>
            <span class="slider-value" id="frequencyValue">4.00</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">INTENSITY</span>
            <div class="slider-wrapper">
              <input type="range" id="intensity" min="0" max="10" step="0.01" value="5.8">
            </div>
            <span class="slider-value" id="intensityValue">5.80</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">STRENGTH</span>
            <div class="slider-wrapper">
              <input type="range" id="strength" min="0" max="10" step="0.01" value="4.2">
            </div>
            <span class="slider-value" id="strengthValue">4.20</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="row row-header">
        <span class="label">BLOOM</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option" data-effect="bloom">
          <div class="row-inner">
            <span class="label">ENABLED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider" id="bloomIntensityRow">
          <div class="row-inner">
            <span class="label">INTENSITY</span>
            <div class="slider-wrapper">
              <input type="range" id="bloomIntensity" min="1" max="10" step="0.1" value="5">
            </div>
            <span class="slider-value" id="bloomIntensityValue">5.0</span>
          </div>
        </div>
        <div class="row row-slider" id="bloomThresholdRow">
          <div class="row-inner">
            <span class="label">THRESHOLD</span>
            <div class="slider-wrapper">
              <input type="range" id="bloomThreshold" min="1" max="10" step="0.1" value="7">
            </div>
            <span class="slider-value" id="bloomThresholdValue">7.0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="row row-header">
        <span class="label">BLUR</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option" data-effect="blur">
          <div class="row-inner">
            <span class="label">ENABLED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider" id="blurStrengthRow">
          <div class="row-inner">
            <span class="label">STRENGTH</span>
            <div class="slider-wrapper">
              <input type="range" id="blurStrength" min="1" max="10" step="0.1" value="3">
            </div>
            <span class="slider-value" id="blurStrengthValue">3.0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="button-row">
      <button class="btn" id="newImageBtn">NEW IMAGE</button>
      <button class="btn" id="resetBtn">RESET</button>
    </div>
  </div>

  <!-- Audio Controls -->
  <div class="audio-controls">
    <span class="audio-controls__label">Audio:</span>
    <button id="audio-play-btn" class="audio-controls__btn">Play</button>
    <label class="audio-controls__btn audio-controls__btn--file">
      Choose File
      <input type="file" id="audio-file-input" class="audio-controls__file-input" accept="audio/*" />
    </label>
    <div class="audio-controls__separator"></div>
    <button id="audio-mic-btn" class="audio-controls__btn">Use Mic</button>
  </div>

  <input type="file" id="fileInput" accept="image/*">

  <script>
    // =====================================================
    // AudioAnalyzer Class (ported from demo8)
    // =====================================================
    class AudioAnalyzer {
      constructor(options = {}) {
        this.bufferSize = options.bufferSize || 512;

        this.audioContext = null;
        this.source = null;
        this.audioElement = null;
        this.mediaStream = null;
        this.meydaAnalyzer = null;
        this.isInitialized = false;
        this.sourceType = 'file';
        this.isPlaying = false;

        this.defaultAmplitude = 0;
        this.currentAmplitude = this.defaultAmplitude;

        // Energy tracking for manual flux calculation
        this.previousRms = 0;
        this.rms = 0;

        // Envelope state
        this.envelopeValue = 0;
        this.attackSpeed = 0.9;
        this.decaySpeed = 0.85;

        // Adaptive threshold
        this.rmsHistory = [];
        this.historySize = 43;
        this.sensitivity = 1.3;
        this.minThreshold = 0.01;

        // Peak tracking for dynamic range
        this.peakRms = 0.01;
        this.peakDecay = 0.995;
      }

      async init() {
        if (this.isInitialized) return;

        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.isInitialized = true;
      }

      setupMeydaAnalyzer() {
        if (this.meydaAnalyzer) {
          this.meydaAnalyzer.stop();
        }

        if (!this.source) return;

        if (typeof Meyda === 'undefined') {
          console.warn('Meyda not loaded - audio analysis unavailable');
          return;
        }

        this.meydaAnalyzer = Meyda.createMeydaAnalyzer({
          audioContext: this.audioContext,
          source: this.source,
          bufferSize: this.bufferSize,
          featureExtractors: ['rms'],
          callback: (features) => {
            if (features && typeof features.rms === 'number') {
              this.previousRms = this.rms;
              this.rms = features.rms;
              this.processFeatures();
            }
          },
        });

        this.meydaAnalyzer.start();
      }

      processFeatures() {
        const flux = Math.max(0, this.rms - this.previousRms);

        if (this.rms > this.peakRms) {
          this.peakRms = this.rms;
        } else {
          this.peakRms *= this.peakDecay;
          this.peakRms = Math.max(this.peakRms, 0.01);
        }

        this.rmsHistory.push(flux);
        if (this.rmsHistory.length > this.historySize) {
          this.rmsHistory.shift();
        }

        const avgFlux = this.rmsHistory.reduce((a, b) => a + b, 0) / this.rmsHistory.length;
        const threshold = Math.max(avgFlux * this.sensitivity, this.minThreshold);

        if (flux > threshold) {
          const relativeIntensity = this.rms / this.peakRms;
          const fluxIntensity = Math.min(flux / threshold, 4) / 4;
          const strength = Math.pow(relativeIntensity, 0.7) * (0.5 + fluxIntensity * 0.5);
          this.envelopeValue = this.envelopeValue + (strength - this.envelopeValue) * this.attackSpeed;
        } else {
          this.envelopeValue *= this.decaySpeed;
        }

        this.currentAmplitude = Math.min(Math.max(this.envelopeValue, 0), 1);
      }

      async loadAudioFile(url) {
        await this.init();
        this.disconnectSource();

        if (!this.audioElement) {
          this.audioElement = new Audio();
          this.audioElement.crossOrigin = 'anonymous';
          this.audioElement.loop = true;
        }

        this.audioElement.src = url;

        this.source = this.audioContext.createMediaElementSource(this.audioElement);
        this.source.connect(this.audioContext.destination);

        this.setupMeydaAnalyzer();
        this.sourceType = 'file';

        return new Promise((resolve, reject) => {
          this.audioElement.addEventListener('canplaythrough', () => resolve(), { once: true });
          this.audioElement.addEventListener('error', reject, { once: true });
          this.audioElement.load();
        });
      }

      async connectMicrophone() {
        await this.init();
        this.disconnectSource();

        try {
          this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.source = this.audioContext.createMediaStreamSource(this.mediaStream);

          this.setupMeydaAnalyzer();
          this.sourceType = 'mic';
          this.isPlaying = true;
        } catch (error) {
          console.error('Microphone access denied:', error);
          throw error;
        }
      }

      disconnectSource() {
        if (this.meydaAnalyzer) {
          this.meydaAnalyzer.stop();
          this.meydaAnalyzer = null;
        }

        if (this.source) {
          this.source.disconnect();
          this.source = null;
        }

        if (this.mediaStream) {
          this.mediaStream.getTracks().forEach(track => track.stop());
          this.mediaStream = null;
        }

        if (this.audioElement) {
          this.audioElement.pause();
          this.audioElement.src = '';
          this.audioElement = null;
        }

        this.rmsHistory = [];
        this.envelopeValue = 0;
        this.previousRms = 0;
        this.rms = 0;
        this.peakRms = 0.01;
        this.isPlaying = false;
      }

      async togglePlay() {
        if (this.sourceType !== 'file' || !this.audioElement) return false;

        if (this.audioContext.state === 'suspended') {
          await this.audioContext.resume();
        }

        if (this.isPlaying) {
          this.audioElement.pause();
          this.isPlaying = false;
        } else {
          await this.audioElement.play();
          this.isPlaying = true;
        }

        return this.isPlaying;
      }

      getAmplitude() {
        if (!this.isPlaying && this.sourceType === 'file') {
          return this.defaultAmplitude;
        }
        return this.currentAmplitude || this.defaultAmplitude;
      }

      dispose() {
        this.disconnectSource();
        if (this.audioContext) {
          this.audioContext.close();
        }
      }
    }

    // =====================================================
    // Vertex Shader (with ripple displacement)
    // =====================================================
    const vertexShaderSource = `
      #define PI 3.14159265359

      varying vec2 vUv;
      varying float vRipple;

      uniform float uTime;
      uniform float uAmplitude;
      uniform float uRippleFreq;
      uniform float uRippleProgress;

      void main() {
        vec3 pos = position;

        // Ripple from center (0.5, 0.5)
        float dist = distance(uv, vec2(0.5, 0.5));
        float decay = clamp(dist, 8.0, 10.0);
        float ripple = sin(-PI * uRippleFreq * dist + uTime) * (uAmplitude / decay);
        ripple *= uRippleProgress;

        // Displace Y position for visible warping (not Z)
        pos.y += ripple;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        vUv = uv;
        vRipple = ripple;
      }
    `;

    // =====================================================
    // Fragment Shader (color processing + ripple brightness)
    // =====================================================
    const fragmentShaderSource = `
      precision highp float;

      varying vec2 vUv;
      varying float vRipple;

      uniform sampler2D uTexture;
      uniform float uTime;
      uniform float uPaletteTime;
      uniform float uSpeed;
      uniform float uFrequency;
      uniform float uIntensity;
      uniform float uStrength;
      uniform vec2 uResolution;
      uniform float uImageAspect;
      uniform float uCanvasAspect;
      uniform float uHueStart;
      uniform float uHueRange;
      uniform float uRippleProgress;
      uniform bool uPaletteEnabled;

      // Post-processing uniforms
      uniform bool uBloomEnabled;
      uniform float uBloomIntensity;
      uniform float uBloomThreshold;
      uniform bool uBlurEnabled;
      uniform float uBlurStrength;

      // Screen blend mode
      vec3 screenBlend(vec3 base, vec3 blend) {
        return 1.0 - (1.0 - base) * (1.0 - blend);
      }

      // Luminance calculation
      float luminance(vec3 color) {
        return dot(color, vec3(0.299, 0.587, 0.114));
      }

      // 9-point Gaussian blur
      vec4 blur9(sampler2D image, vec2 uv, vec2 texelSize, float strength) {
        vec4 color = vec4(0.0);
        vec2 off = texelSize * strength;

        color += texture2D(image, uv + off * vec2(-1.0,  1.0)) * 0.0625;
        color += texture2D(image, uv + off * vec2( 0.0,  1.0)) * 0.125;
        color += texture2D(image, uv + off * vec2( 1.0,  1.0)) * 0.0625;
        color += texture2D(image, uv + off * vec2(-1.0,  0.0)) * 0.125;
        color += texture2D(image, uv)                          * 0.25;
        color += texture2D(image, uv + off * vec2( 1.0,  0.0)) * 0.125;
        color += texture2D(image, uv + off * vec2(-1.0, -1.0)) * 0.0625;
        color += texture2D(image, uv + off * vec2( 0.0, -1.0)) * 0.125;
        color += texture2D(image, uv + off * vec2( 1.0, -1.0)) * 0.0625;

        return color;
      }

      // RGB to HSL conversion
      vec3 rgb2hsl(vec3 c) {
        float maxC = max(c.r, max(c.g, c.b));
        float minC = min(c.r, min(c.g, c.b));
        float l = (maxC + minC) * 0.5;

        if (maxC == minC) {
          return vec3(0.0, 0.0, l);
        }

        float d = maxC - minC;
        float s = l > 0.5 ? d / (2.0 - maxC - minC) : d / (maxC + minC);

        float h;
        if (maxC == c.r) {
          h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
        } else if (maxC == c.g) {
          h = (c.b - c.r) / d + 2.0;
        } else {
          h = (c.r - c.g) / d + 4.0;
        }
        h /= 6.0;

        return vec3(h, s, l);
      }

      // Hue to RGB helper
      float hue2rgb(float p, float q, float t) {
        if (t < 0.0) t += 1.0;
        if (t > 1.0) t -= 1.0;
        if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
        if (t < 1.0/2.0) return q;
        if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
        return p;
      }

      // HSL to RGB conversion
      vec3 hsl2rgb(vec3 hsl) {
        float h = hsl.x;
        float s = hsl.y;
        float l = hsl.z;

        if (s == 0.0) {
          return vec3(l);
        }

        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
        float p = 2.0 * l - q;

        float r = hue2rgb(p, q, h + 1.0/3.0);
        float g = hue2rgb(p, q, h);
        float b = hue2rgb(p, q, h - 1.0/3.0);

        return vec3(r, g, b);
      }

      void main() {
        vec2 uv = vUv;

        vec4 texColor = texture2D(uTexture, uv);
        vec3 finalColor;

        if (uPaletteEnabled) {
          // Convert to HSL
          vec3 hsl = rgb2hsl(texColor.rgb);
          float luma = hsl.z;

          // Time-based animation (uses separate palette time)
          float timeOffset = uPaletteTime * uSpeed * 0.02;
          float lumaPosition = luma * uIntensity * 0.2;
          float hue = uHueStart + fract(lumaPosition + timeOffset) * uHueRange;
          hsl.x = fract(hue);

          // Saturation boost
          hsl.y = min(1.0, hsl.y + uStrength * 0.15);

          // Luminance adjustment
          hsl.z = hsl.z * (0.8 + uFrequency * 0.05) + 0.1;
          hsl.z = clamp(hsl.z, 0.0, 1.0);

          // Convert back to RGB
          finalColor = hsl2rgb(hsl);
        } else {
          // No palette - use original colors
          finalColor = texColor.rgb;
        }

        // Add ripple brightness variation
        finalColor += vRipple * 2.0 * uRippleProgress;

        // Apply blur effect
        if (uBlurEnabled) {
          vec2 texelSize = 1.0 / uResolution;
          vec4 blurredColor = blur9(uTexture, uv, texelSize, uBlurStrength * 2.0);

          vec3 processedBlur;
          if (uPaletteEnabled) {
            // Apply palette color processing to blurred samples
            vec3 blurHsl = rgb2hsl(blurredColor.rgb);
            float blurLuma = blurHsl.z;
            float blurTimeOffset = uPaletteTime * uSpeed * 0.02;
            float blurLumaPosition = blurLuma * uIntensity * 0.2;
            float blurHue = uHueStart + fract(blurLumaPosition + blurTimeOffset) * uHueRange;
            blurHsl.x = fract(blurHue);
            blurHsl.y = min(1.0, blurHsl.y + uStrength * 0.15);
            blurHsl.z = blurHsl.z * (0.8 + uFrequency * 0.05) + 0.1;
            blurHsl.z = clamp(blurHsl.z, 0.0, 1.0);
            processedBlur = hsl2rgb(blurHsl);
          } else {
            // Use original blurred colors without palette processing
            processedBlur = blurredColor.rgb;
          }

          finalColor = mix(finalColor, processedBlur, uBlurStrength * 0.1);
        }

        // Apply bloom effect
        if (uBloomEnabled) {
          float lum = luminance(finalColor);
          float threshold = uBloomThreshold * 0.1;
          float bloomMask = smoothstep(threshold, threshold + 0.1, lum);
          vec3 bloomColor = finalColor * bloomMask;

          vec2 texelSize = 1.0 / uResolution;
          vec3 bloomBlur = vec3(0.0);
          float blurRadius = uBloomIntensity * 0.5;

          for (float x = -2.0; x <= 2.0; x += 1.0) {
            for (float y = -2.0; y <= 2.0; y += 1.0) {
              vec2 offset = vec2(x, y) * texelSize * blurRadius;
              vec4 sampleColor = texture2D(uTexture, uv + offset);
              vec3 sampleHsl = rgb2hsl(sampleColor.rgb);
              float sampleLum = sampleHsl.z;
              if (sampleLum > threshold) {
                bloomBlur += sampleColor.rgb * (sampleLum - threshold);
              }
            }
          }
          bloomBlur /= 25.0;

          vec3 bloomProcessed = bloomBlur * (uBloomIntensity * 0.3);
          finalColor = screenBlend(finalColor, bloomProcessed);
        }

        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

    // =====================================================
    // Wireframe Fragment Shader (dark grey)
    // =====================================================
    const wireframeFragmentShader = `
      precision highp float;

      void main() {
        gl_FragColor = vec4(0.3, 0.3, 0.3, 0.6);
      }
    `;

    // =====================================================
    // Three.js Setup
    // =====================================================
    const canvas = document.getElementById('glCanvas');

    // Create renderer
    const renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance'
    });
    renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Create scene
    const scene = new THREE.Scene();

    // Create orthographic camera (sized to viewport)
    const { innerWidth: width, innerHeight: height } = window;
    const camera = new THREE.OrthographicCamera(
      -width / 2, width / 2,
      height / 2, -height / 2,
      -1000, 1000
    );
    camera.position.z = 10;

    // Create geometry with high subdivision for smooth ripple
    const geometry = new THREE.PlaneGeometry(1, 1, 100, 100);

    // Image display settings
    const maxImageWidth = 600;  // Max width like index8
    const imageAspectRatio = 3 / 4;  // Default aspect ratio

    // Create shader material
    let material;
    let mesh;
    let texture;

    // Wireframe overlay
    let wireframeMaterial;
    let wireframeMesh;
    let wireframeEnabled = false;
    let imageVisible = true;

    // State variables
    let speed = 0.5;
    let frequency = 4;
    let intensity = 5.8;
    let strength = 4.2;
    let imageLoaded = false;
    let imageAspect = 1;

    // Palette state (full spectrum: hueStart=0, hueRange=1)
    let paletteEnabled = true;
    const hueStart = 0.0;
    const hueRange = 1.0;

    // Ripple state
    let rippleEnabled = false;
    let rippleFreq = 8.0;
    let rippleAmplitude = 0.02;  // Match index8 baseAmplitude
    let rippleSpeed = 0.1;
    let rippleTime = 0;

    // Palette time (independent of ripple)
    let paletteTime = 0;

    // Post-processing state
    let bloomEnabled = false;
    let bloomIntensity = 5;
    let bloomThreshold = 7;
    let blurEnabled = false;
    let blurStrength = 3;

    // Audio analyzer
    const audioAnalyzer = new AudioAnalyzer({ bufferSize: 512 });
    const audioMultiplier = 0.3;
    const maxAmplitude = 0.35;

    // Default values for reset
    const defaults = {
      paletteEnabled: true, speed: 0.5, frequency: 4, intensity: 5.8, strength: 4.2,
      rippleEnabled: false, rippleFreq: 8.0, rippleAmplitude: 0.02, rippleSpeed: 0.1,
      imageVisible: true, wireframeEnabled: false,
      bloomEnabled: false, bloomIntensity: 5, bloomThreshold: 7,
      blurEnabled: false, blurStrength: 3
    };

    // Create material with uniforms
    function createMaterial(tex) {
      return new THREE.ShaderMaterial({
        vertexShader: vertexShaderSource,
        fragmentShader: fragmentShaderSource,
        uniforms: {
          uTexture: { value: tex },
          uTime: { value: 0 },
          uPaletteTime: { value: 0 },
          uSpeed: { value: speed },
          uFrequency: { value: frequency },
          uIntensity: { value: intensity },
          uStrength: { value: strength },
          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          uImageAspect: { value: imageAspect },
          uCanvasAspect: { value: window.innerWidth / window.innerHeight },
          uHueStart: { value: hueStart },
          uHueRange: { value: hueRange },
          uPaletteEnabled: { value: paletteEnabled },
          uRippleProgress: { value: 0 },
          uAmplitude: { value: rippleAmplitude },
          uRippleFreq: { value: rippleFreq },
          uBloomEnabled: { value: bloomEnabled },
          uBloomIntensity: { value: bloomIntensity },
          uBloomThreshold: { value: bloomThreshold },
          uBlurEnabled: { value: blurEnabled },
          uBlurStrength: { value: blurStrength }
        }
      });
    }

    // Calculate mesh size based on image aspect and viewport
    function calculateMeshSize() {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Use max width but ensure it fits in viewport with some padding
      let meshWidth = Math.min(maxImageWidth, viewportWidth * 0.8);
      let meshHeight = meshWidth / imageAspect;

      // If height exceeds viewport, scale down
      if (meshHeight > viewportHeight * 0.8) {
        meshHeight = viewportHeight * 0.8;
        meshWidth = meshHeight * imageAspect;
      }

      return { width: meshWidth, height: meshHeight };
    }

    // Create wireframe material
    function createWireframeMaterial() {
      return new THREE.ShaderMaterial({
        vertexShader: vertexShaderSource,
        fragmentShader: wireframeFragmentShader,
        wireframe: true,
        transparent: true,
        depthTest: false,
        uniforms: {
          uTime: { value: 0 },
          uAmplitude: { value: rippleAmplitude },
          uRippleFreq: { value: rippleFreq },
          uRippleProgress: { value: 0 }
        }
      });
    }

    // Load image
    function loadImage(src) {
      const loader = new THREE.TextureLoader();
      loader.load(src, (tex) => {
        texture = tex;
        imageAspect = tex.image.width / tex.image.height;

        if (mesh) {
          scene.remove(mesh);
          material.dispose();
        }

        if (wireframeMesh) {
          scene.remove(wireframeMesh);
          wireframeMaterial.dispose();
        }

        material = createMaterial(texture);
        mesh = new THREE.Mesh(geometry, material);

        // Create wireframe mesh
        wireframeMaterial = createWireframeMaterial();
        wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
        wireframeMesh.visible = wireframeEnabled;

        // Scale mesh to image size
        const size = calculateMeshSize();
        mesh.scale.set(size.width, size.height, 1);
        wireframeMesh.scale.set(size.width, size.height, 1);

        scene.add(mesh);
        scene.add(wireframeMesh);

        imageLoaded = true;
      });
    }

    // Load default image
    function loadDefaultImage() {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = function() {
        loadImage(img.src);
      };
      img.onerror = function() {
        // Fallback gradient (3:4 aspect ratio)
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 600;
        tempCanvas.height = 800;
        const ctx = tempCanvas.getContext('2d');
        const gradient = ctx.createRadialGradient(300, 400, 50, 300, 400, 400);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.5, '#666666');
        gradient.addColorStop(1, '#222222');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 600, 800);
        loadImage(tempCanvas.toDataURL());
      };
      img.src = 'statue.jpg';
    }

    // Resize handler
    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      renderer.setSize(w, h);

      // Update camera
      camera.left = -w / 2;
      camera.right = w / 2;
      camera.top = h / 2;
      camera.bottom = -h / 2;
      camera.updateProjectionMatrix();

      // Update mesh size
      if (mesh) {
        const size = calculateMeshSize();
        mesh.scale.set(size.width, size.height, 1);
        if (wireframeMesh) {
          wireframeMesh.scale.set(size.width, size.height, 1);
        }
      }

      if (material) {
        material.uniforms.uResolution.value.set(w, h);
        material.uniforms.uCanvasAspect.value = w / h;
      }
    }

    window.addEventListener('resize', resize);

    // Animation loop
    let startTime = Date.now();

    function render() {
      if (!imageLoaded || !material) {
        requestAnimationFrame(render);
        return;
      }

      const time = (Date.now() - startTime) / 1000;

      // Update ripple time
      rippleTime += rippleSpeed;

      // Update palette time (independent, fixed rate)
      paletteTime += 0.1;

      // Get audio amplitude
      const audioLevel = audioAnalyzer.getAmplitude();
      const baseAmp = rippleAmplitude;
      const finalAmp = Math.min(baseAmp + (audioLevel * audioMultiplier), maxAmplitude);

      // Update uniforms
      material.uniforms.uTime.value = rippleTime;
      material.uniforms.uPaletteTime.value = paletteTime;
      material.uniforms.uSpeed.value = speed;
      material.uniforms.uFrequency.value = frequency;
      material.uniforms.uIntensity.value = intensity;
      material.uniforms.uStrength.value = strength;
      material.uniforms.uHueStart.value = hueStart;
      material.uniforms.uHueRange.value = hueRange;
      material.uniforms.uPaletteEnabled.value = paletteEnabled;
      material.uniforms.uImageAspect.value = imageAspect;
      material.uniforms.uRippleProgress.value = rippleEnabled ? 1.0 : 0.0;
      material.uniforms.uAmplitude.value = finalAmp;
      material.uniforms.uRippleFreq.value = rippleFreq;
      material.uniforms.uBloomEnabled.value = bloomEnabled;
      material.uniforms.uBloomIntensity.value = bloomIntensity;
      material.uniforms.uBloomThreshold.value = bloomThreshold;
      material.uniforms.uBlurEnabled.value = blurEnabled;
      material.uniforms.uBlurStrength.value = blurStrength;

      // Sync wireframe uniforms
      if (wireframeMaterial) {
        wireframeMaterial.uniforms.uTime.value = rippleTime;
        wireframeMaterial.uniforms.uAmplitude.value = finalAmp;
        wireframeMaterial.uniforms.uRippleFreq.value = rippleFreq;
        wireframeMaterial.uniforms.uRippleProgress.value = rippleEnabled ? 1.0 : 0.0;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    // =====================================================
    // UI Event Handlers
    // =====================================================

    // Slider helpers
    function updateSliderFill(slider) {
      const min = parseFloat(slider.min);
      const max = parseFloat(slider.max);
      const val = parseFloat(slider.value);
      const percent = ((val - min) / (max - min)) * 100;
      slider.style.setProperty('--value-percent', percent + '%');
    }

    function setupSlider(id, updateFn, decimals = 2) {
      const slider = document.getElementById(id);
      const valueDisplay = document.getElementById(id + 'Value');

      updateSliderFill(slider);

      slider.addEventListener('input', () => {
        const val = parseFloat(slider.value);
        valueDisplay.textContent = val.toFixed(decimals);
        updateSliderFill(slider);
        updateFn(val);
      });
    }

    // Palette sliders
    setupSlider('speed', v => speed = v);
    setupSlider('frequency', v => frequency = v);
    setupSlider('intensity', v => intensity = v);
    setupSlider('strength', v => strength = v);

    // Ripple sliders
    setupSlider('rippleFreq', v => rippleFreq = v, 1);
    setupSlider('rippleAmplitude', v => rippleAmplitude = v);
    setupSlider('rippleSpeed', v => rippleSpeed = v);

    // Post-processing sliders
    setupSlider('bloomIntensity', v => bloomIntensity = v, 1);
    setupSlider('bloomThreshold', v => bloomThreshold = v, 1);
    setupSlider('blurStrength', v => blurStrength = v, 1);

    // Effect toggles (ripple, palette, bloom, blur, wireframe)
    document.querySelectorAll('[data-effect]').forEach(option => {
      option.addEventListener('click', () => {
        const effectName = option.dataset.effect;

        if (effectName === 'ripple') {
          rippleEnabled = !rippleEnabled;
          option.classList.toggle('active', rippleEnabled);
        } else if (effectName === 'palette') {
          paletteEnabled = !paletteEnabled;
          option.classList.toggle('active', paletteEnabled);
        } else if (effectName === 'bloom') {
          bloomEnabled = !bloomEnabled;
          option.classList.toggle('active', bloomEnabled);
        } else if (effectName === 'blur') {
          blurEnabled = !blurEnabled;
          option.classList.toggle('active', blurEnabled);
        } else if (effectName === 'image') {
          imageVisible = !imageVisible;
          option.classList.toggle('active', imageVisible);
          if (mesh) {
            mesh.visible = imageVisible;
          }
        } else if (effectName === 'wireframe') {
          wireframeEnabled = !wireframeEnabled;
          option.classList.toggle('active', wireframeEnabled);
          if (wireframeMesh) {
            wireframeMesh.visible = wireframeEnabled;
          }
        }
      });
    });

    // Buttons
    document.getElementById('newImageBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      speed = defaults.speed;
      frequency = defaults.frequency;
      intensity = defaults.intensity;
      strength = defaults.strength;

      const speedSlider = document.getElementById('speed');
      const frequencySlider = document.getElementById('frequency');
      const intensitySlider = document.getElementById('intensity');
      const strengthSlider = document.getElementById('strength');

      speedSlider.value = speed;
      frequencySlider.value = frequency;
      intensitySlider.value = intensity;
      strengthSlider.value = strength;

      updateSliderFill(speedSlider);
      updateSliderFill(frequencySlider);
      updateSliderFill(intensitySlider);
      updateSliderFill(strengthSlider);

      document.getElementById('speedValue').textContent = speed.toFixed(2);
      document.getElementById('frequencyValue').textContent = frequency.toFixed(2);
      document.getElementById('intensityValue').textContent = intensity.toFixed(2);
      document.getElementById('strengthValue').textContent = strength.toFixed(2);

      // Reset palette
      paletteEnabled = defaults.paletteEnabled;

      // Reset ripple
      rippleEnabled = defaults.rippleEnabled;
      rippleFreq = defaults.rippleFreq;
      rippleAmplitude = defaults.rippleAmplitude;
      rippleSpeed = defaults.rippleSpeed;

      const rippleFreqSlider = document.getElementById('rippleFreq');
      const rippleAmplitudeSlider = document.getElementById('rippleAmplitude');
      const rippleSpeedSlider = document.getElementById('rippleSpeed');

      rippleFreqSlider.value = rippleFreq;
      rippleAmplitudeSlider.value = rippleAmplitude;
      rippleSpeedSlider.value = rippleSpeed;

      updateSliderFill(rippleFreqSlider);
      updateSliderFill(rippleAmplitudeSlider);
      updateSliderFill(rippleSpeedSlider);

      document.getElementById('rippleFreqValue').textContent = rippleFreq.toFixed(1);
      document.getElementById('rippleAmplitudeValue').textContent = rippleAmplitude.toFixed(2);
      document.getElementById('rippleSpeedValue').textContent = rippleSpeed.toFixed(2);

      // Reset image visibility
      imageVisible = defaults.imageVisible;
      if (mesh) {
        mesh.visible = imageVisible;
      }

      // Reset wireframe
      wireframeEnabled = defaults.wireframeEnabled;
      if (wireframeMesh) {
        wireframeMesh.visible = wireframeEnabled;
      }

      // Reset post-processing
      bloomEnabled = defaults.bloomEnabled;
      bloomIntensity = defaults.bloomIntensity;
      bloomThreshold = defaults.bloomThreshold;
      blurEnabled = defaults.blurEnabled;
      blurStrength = defaults.blurStrength;

      const bloomIntensitySlider = document.getElementById('bloomIntensity');
      const bloomThresholdSlider = document.getElementById('bloomThreshold');
      const blurStrengthSlider = document.getElementById('blurStrength');

      bloomIntensitySlider.value = bloomIntensity;
      bloomThresholdSlider.value = bloomThreshold;
      blurStrengthSlider.value = blurStrength;

      updateSliderFill(bloomIntensitySlider);
      updateSliderFill(bloomThresholdSlider);
      updateSliderFill(blurStrengthSlider);

      document.getElementById('bloomIntensityValue').textContent = bloomIntensity.toFixed(1);
      document.getElementById('bloomThresholdValue').textContent = bloomThreshold.toFixed(1);
      document.getElementById('blurStrengthValue').textContent = blurStrength.toFixed(1);

      // Reset effect toggle UI states
      document.querySelectorAll('[data-effect]').forEach(opt => {
        const effect = opt.dataset.effect;
        if (effect === 'palette') {
          opt.classList.toggle('active', defaults.paletteEnabled);
        } else if (effect === 'ripple') {
          opt.classList.toggle('active', defaults.rippleEnabled);
        } else if (effect === 'image') {
          opt.classList.toggle('active', defaults.imageVisible);
        } else if (effect === 'wireframe') {
          opt.classList.toggle('active', defaults.wireframeEnabled);
        } else if (effect === 'bloom') {
          opt.classList.toggle('active', defaults.bloomEnabled);
        } else if (effect === 'blur') {
          opt.classList.toggle('active', defaults.blurEnabled);
        }
      });
    });

    // File input
    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          loadImage(event.target.result);
        };
        reader.readAsDataURL(file);
      }
    });

    // Drag and drop
    const dropZone = document.getElementById('dropZone');

    document.body.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('active');
    });

    document.body.addEventListener('dragleave', (e) => {
      e.preventDefault();
      if (e.relatedTarget === null || !document.body.contains(e.relatedTarget)) {
        dropZone.classList.remove('active');
      }
    });

    document.body.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('active');

      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (event) => {
          loadImage(event.target.result);
        };
        reader.readAsDataURL(file);
      }
    });

    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropZone.classList.remove('active');
    });

    // Section expand/collapse
    document.querySelectorAll('.row-header').forEach(header => {
      header.addEventListener('click', () => {
        const section = header.closest('.section');
        const rows = section.querySelectorAll('.section-content .row');
        const isCollapsing = !section.classList.contains('collapsed');
        const staggerDelay = 0.4;

        if (isCollapsing) {
          rows.forEach((row, index) => {
            const delay = (rows.length - 1 - index) * staggerDelay;
            row.style.setProperty('--row-delay', `${delay}s`);
            const inner = row.querySelector('.row-inner');
            if (inner) inner.style.setProperty('--row-delay', `${delay}s`);
          });
          section.classList.add('collapsed');
        } else {
          rows.forEach((row, index) => {
            const delay = index * staggerDelay;
            row.style.setProperty('--row-delay', `${delay}s`);
            const inner = row.querySelector('.row-inner');
            if (inner) inner.style.setProperty('--row-delay', `${delay}s`);
          });
          section.classList.remove('collapsed');
        }
      });
    });

    // =====================================================
    // Audio Controls
    // =====================================================
    const playBtn = document.getElementById('audio-play-btn');
    const micBtn = document.getElementById('audio-mic-btn');
    const audioFileInput = document.getElementById('audio-file-input');

    audioFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        await audioAnalyzer.init();
        const url = URL.createObjectURL(file);
        await audioAnalyzer.loadAudioFile(url);

        const isPlaying = await audioAnalyzer.togglePlay();
        playBtn.textContent = isPlaying ? 'Pause' : 'Play';
        playBtn.classList.toggle('active', isPlaying);
      }
    });

    playBtn.addEventListener('click', async () => {
      await audioAnalyzer.init();

      if (!audioAnalyzer.audioElement?.src) {
        audioFileInput.click();
        return;
      }

      const isPlaying = await audioAnalyzer.togglePlay();
      playBtn.textContent = isPlaying ? 'Pause' : 'Play';
      playBtn.classList.toggle('active', isPlaying);
    });

    micBtn.addEventListener('click', async () => {
      await audioAnalyzer.init();

      if (audioAnalyzer.sourceType === 'mic' && audioAnalyzer.isPlaying) {
        audioAnalyzer.disconnectSource();
        micBtn.textContent = 'Use Mic';
        micBtn.classList.remove('active');
        playBtn.disabled = false;
      } else {
        try {
          await audioAnalyzer.connectMicrophone();
          micBtn.textContent = 'Stop Mic';
          micBtn.classList.add('active');
          playBtn.disabled = true;
          playBtn.textContent = 'Play';
          playBtn.classList.remove('active');
        } catch (e) {
          alert('Microphone access denied. Please allow microphone access.');
        }
      }
    });

    // =====================================================
    // Start
    // =====================================================
    loadDefaultImage();
    render();
  </script>
</body>
</html>
