<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pattern Effect Tool</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
  <script src="https://unpkg.com/meyda@5.2.1/dist/web/meyda.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #ffffff;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    #glCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .controls-panel {
      position: fixed;
      top: 30px;
      right: 30px;
      width: 400px;
      display: flex;
      flex-direction: column;
      gap: 1.5px;
      opacity: 1;
      transition: opacity 0.6s ease-out;
    }

    .controls-panel.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .section {
      background: transparent;
    }

    .row {
      height: 54px;
      display: flex;
      align-items: center;
      padding: 0 20px;
      cursor: pointer;
      position: relative;
      transition: background 0.15s ease;
      background: rgba(0,0,0,0.12);
    }

    .row:hover {
      background: rgba(0,0,0,0.35);
    }

    .row-header {
      justify-content: space-between;
      background: rgba(38, 41, 47, 0.7);
      backdrop-filter: blur(20px);
    }

    .row-header .label {
      font-size: 13.5px;
      font-weight: 700;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
    }

    .row-header .arrow {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 5px solid #fff;
      transition: transform 0.4s ease;
    }

    .section.collapsed .row-header .arrow {
      transform: rotate(-90deg);
    }

    .section-content {
      display: flex;
      flex-direction: column;
    }

    .section-content .row {
      height: 54px;
      padding: 0;
      overflow: hidden;
      flex-shrink: 0;
      background: rgba(45, 48, 54, 0.7);
      backdrop-filter: blur(20px);
      transition: height 0.4s ease var(--row-delay, 0s);
      display: block;
    }

    .section-content .row-inner {
      height: 54px;
      display: flex;
      align-items: center;
      padding: 0 20px;
      transform: translateY(0);
      transition: transform 0.4s ease var(--row-delay, 0s);
    }

    .section-content .row-option .row-inner {
      justify-content: space-between;
      width: 100%;
    }

    .section-content .row-slider .row-inner {
      width: 100%;
    }

    .section-content .row:hover {
      background: rgba(0,0,0,0.35);
    }

    .section-content .row.row-slider,
    .section-content .row.row-option {
      background: rgba(58, 62, 68, 0.7);
    }

    .section-content .row.row-slider:hover,
    .section-content .row.row-option:hover {
      background: rgba(0,0,0,0.35);
    }

    .section.collapsed .section-content .row {
      height: 0;
    }

    .section.collapsed .section-content .row-inner {
      transform: translateY(-54px);
    }

    .row-option {
      justify-content: space-between;
    }

    .row-option .label {
      font-size: 13.5px;
      font-weight: 400;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
    }

    .row-option .check {
      opacity: 0;
      transition: opacity 0.15s ease;
    }

    .row-option.active .check {
      opacity: 1;
    }

    .check svg {
      width: 16px;
      height: 16px;
      color: #fff;
    }

    .row-option + .row-slider .row-inner,
    .row-slider + .row-slider .row-inner,
    .row-option + .row-option .row-inner {
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .row-slider .label {
      font-size: 13.5px;
      font-weight: 400;
      letter-spacing: -0.25px;
      line-height: 1;
      color: #fff;
      flex-shrink: 0;
      width: 80px;
      margin-right: 40px;
    }

    .slider-wrapper {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      margin-right: 20px;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 2px;
      background: linear-gradient(to right, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.9) var(--value-percent, 50%), rgba(255,255,255,0.25) var(--value-percent, 50%), rgba(255,255,255,0.25) 100%);
      border-radius: 1px;
      outline: none;
      cursor: pointer;
      margin: 0;
      padding: 0;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 4.5px;
      height: 9px;
      background: #fff;
      border-radius: 1px;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 4.5px;
      height: 9px;
      background: #fff;
      border-radius: 1px;
      cursor: pointer;
      border: none;
    }

    input[type="range"]::-moz-range-progress {
      background: rgba(255,255,255,0.9);
      height: 2px;
    }

    .slider-value {
      padding: 4px;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: -0.25px;
      line-height: 1;
      font-variant-numeric: tabular-nums;
      color: #fff;
      text-align: center;
      flex-shrink: 0;
      background: rgba(0,0,0,0.35);
      border-radius: 3px;
    }

    .button-row {
      display: flex;
      gap: 1px;
    }

    .btn {
      flex: 1;
      height: 54px;
      font-size: 13.5px;
      font-weight: 700;
      letter-spacing: -0.25px;
      line-height: 1;
      cursor: pointer;
      transition: background 0.15s ease;
      background: rgba(38, 41, 47, 0.7);
      backdrop-filter: blur(20px);
      border: none;
      color: #fff;
      font-family: inherit;
    }

    .btn:hover {
      background: rgba(0,0,0,0.35);
    }

    .drop-zone {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 10;
    }

    .drop-zone.active {
      opacity: 1;
      pointer-events: auto;
    }

    .drop-zone-content {
      text-align: center;
      color: rgba(255,255,255,0.7);
    }

    .drop-zone-content svg {
      width: 48px;
      height: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    #fileInput {
      display: none;
    }

    /* Audio Controls Panel - positioned bottom left, uses same styles as controls-panel */
    .audio-panel {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 400px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 1.5px;
    }

    .audio-panel .btn.active {
      background: rgba(40, 75, 50, 0.7);
    }

    .audio-panel .btn.active:hover {
      background: rgba(0,0,0,0.35);
    }

    #audioMicBtn.active {
      background: rgba(120, 40, 40, 0.7);
    }

    #audioMicBtn.active:hover {
      background: rgba(0,0,0,0.35);
    }

    /* Audio panel: no translate needed - panel shift from bottom anchor handles positioning */
    .audio-panel .section.collapsed .section-content .row-inner {
      transform: translateY(0);
    }

    #audioFileInput {
      display: none;
    }

    /* Mode Toggle Buttons */
    .mode-toggle {
      position: fixed;
      top: 30px;
      left: 30px;
      z-index: 1001;
      width: 400px;
      display: flex;
      gap: 1px;
    }

    .mode-btn {
      flex: 1;
      height: 54px;
      background: rgba(38, 41, 47, 0.7);
      backdrop-filter: blur(20px);
      border: none;
      color: #fff;
      font-family: inherit;
      font-size: 13.5px;
      font-weight: 700;
      letter-spacing: -0.25px;
      line-height: 1;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .mode-btn:hover,
    .mode-btn.active {
      background: rgba(0,0,0,0.35);
    }

    /* Text Stack (hover mode only) */
    .text-stack {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      text-align: left;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.6s ease-out;
      z-index: 10;
    }

    .text-stack.visible {
      opacity: 1;
    }

    .text-stack__header {
      font-size: 32px;
      line-height: 32px;
      font-weight: 700;
      color: #000;
      text-transform: uppercase;
      margin: 0;
    }

    .text-stack__paragraph {
      font-size: 16px;
      line-height: 20.8px;
      font-weight: 400;
      color: #000;
      margin: 22px 0 0 0;
    }

    .text-stack__label {
      font-size: 12px;
      line-height: 10.8px;
      font-weight: 700;
      color: #767676;
      text-transform: uppercase;
      margin: 22px 0 0 0;
    }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>

  <!-- Text Stack (hover mode only) -->
  <div class="text-stack" id="textStack">
    <h1 class="text-stack__header">POKEMON</h1>
    <p class="text-stack__paragraph">A piece of music featuring the iconic character Snorlax, striking the balance between the enchanting and nostalgic childhood moments.</p>
    <p class="text-stack__label">ENTERTAINMENT</p>
  </div>

  <!-- Mode Toggle -->
  <div class="mode-toggle">
    <button class="mode-btn active" data-mode="edit">EDIT MODE</button>
    <button class="mode-btn" data-mode="hover">HOVER MODE</button>
  </div>

  <div class="drop-zone" id="dropZone">
    <div class="drop-zone-content">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
      </svg>
      <p>Drop image here</p>
    </div>
  </div>

  <div class="controls-panel">
    <div class="section">
      <div class="row row-header">
        <span class="label">PATTERN</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option active" data-effect="ripple">
          <div class="row-inner">
            <span class="label">ENABLED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-option active" data-effect="image">
          <div class="row-inner">
            <span class="label">IMAGE</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-option" data-effect="wireframe">
          <div class="row-inner">
            <span class="label">WIREFRAME</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">FREQUENCY</span>
            <div class="slider-wrapper">
              <input type="range" id="rippleFreq" min="1" max="20" step="0.1" value="13.5">
            </div>
            <span class="slider-value" id="rippleFreqValue">13.5</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">AMPLITUDE</span>
            <div class="slider-wrapper">
              <input type="range" id="rippleAmplitude" min="0.01" max="0.20" step="0.01" value="0.05">
            </div>
            <span class="slider-value" id="rippleAmplitudeValue">0.05</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">SPEED</span>
            <div class="slider-wrapper">
              <input type="range" id="rippleSpeed" min="0.01" max="0.10" step="0.01" value="0.05">
            </div>
            <span class="slider-value" id="rippleSpeedValue">0.05</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section collapsed">
      <div class="row row-header">
        <span class="label">PALETTE</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option active" data-effect="palette">
          <div class="row-inner">
            <span class="label">ENABLED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">SPEED</span>
            <div class="slider-wrapper">
              <input type="range" id="speed" min="0" max="1" step="0.01" value="0.5">
            </div>
            <span class="slider-value" id="speedValue">0.50</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">FREQUENCY</span>
            <div class="slider-wrapper">
              <input type="range" id="frequency" min="0.5" max="10" step="0.01" value="4">
            </div>
            <span class="slider-value" id="frequencyValue">4.00</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">INTENSITY</span>
            <div class="slider-wrapper">
              <input type="range" id="intensity" min="0" max="10" step="0.01" value="2.5">
            </div>
            <span class="slider-value" id="intensityValue">2.50</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">STRENGTH</span>
            <div class="slider-wrapper">
              <input type="range" id="strength" min="0" max="10" step="0.01" value="2.5">
            </div>
            <span class="slider-value" id="strengthValue">2.50</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section collapsed">
      <div class="row row-header">
        <span class="label">BLOOM</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option active" data-effect="bloom">
          <div class="row-inner">
            <span class="label">ENABLED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider" id="bloomIntensityRow">
          <div class="row-inner">
            <span class="label">INTENSITY</span>
            <div class="slider-wrapper">
              <input type="range" id="bloomIntensity" min="1" max="10" step="0.1" value="7.5">
            </div>
            <span class="slider-value" id="bloomIntensityValue">7.5</span>
          </div>
        </div>
        <div class="row row-slider" id="bloomThresholdRow">
          <div class="row-inner">
            <span class="label">THRESHOLD</span>
            <div class="slider-wrapper">
              <input type="range" id="bloomThreshold" min="1" max="10" step="0.1" value="5">
            </div>
            <span class="slider-value" id="bloomThresholdValue">5.0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section collapsed">
      <div class="row row-header">
        <span class="label">BLUR</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option active" data-effect="blur">
          <div class="row-inner">
            <span class="label">ENABLED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider" id="blurStrengthRow">
          <div class="row-inner">
            <span class="label">STRENGTH</span>
            <div class="slider-wrapper">
              <input type="range" id="blurStrength" min="1" max="10" step="0.1" value="5">
            </div>
            <span class="slider-value" id="blurStrengthValue">5.0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section collapsed">
      <div class="row row-header">
        <span class="label">GRAIN</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option active" data-effect="grain">
          <div class="row-inner">
            <span class="label">ENABLED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-option active" data-effect="grainAnimated">
          <div class="row-inner">
            <span class="label">ANIMATED</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">INTENSITY</span>
            <div class="slider-wrapper">
              <input type="range" id="grainIntensity" min="0.005" max="0.10" step="0.005" value="0.02">
            </div>
            <span class="slider-value" id="grainIntensityValue">0.020</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">SCALE</span>
            <div class="slider-wrapper">
              <input type="range" id="grainScale" min="0.001" max="50" step="0.001" value="2.5">
            </div>
            <span class="slider-value" id="grainScaleValue">2.500</span>
          </div>
        </div>
        <div class="row row-slider">
          <div class="row-inner">
            <span class="label">SPEED</span>
            <div class="slider-wrapper">
              <input type="range" id="grainSpeed" min="0.001" max="1" step="0.001" value="0.75">
            </div>
            <span class="slider-value" id="grainSpeedValue">0.750</span>
          </div>
        </div>
      </div>
    </div>

    <div class="button-row">
      <button class="btn" id="newImageBtn">NEW IMAGE</button>
      <button class="btn" id="resetBtn">RESET</button>
    </div>
  </div>

  <!-- Audio Controls Panel -->
  <div class="audio-panel">
    <div class="section">
      <div class="row row-header">
        <span class="label">AUDIO</span>
        <span class="arrow"></span>
      </div>
      <div class="section-content">
        <div class="row row-option" id="audio-play-toggle">
          <div class="row-inner">
            <span class="label">PLAY / PAUSE</span>
            <span class="check"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 13l4 4L19 7" /></svg></span>
          </div>
        </div>
      </div>
    </div>
    <div class="button-row">
      <button class="btn" id="audioChooseFileBtn">CHOOSE FILE</button>
      <button class="btn" id="audioMicBtn">USE MIC</button>
    </div>
    <input type="file" id="audioFileInput" accept="audio/*" />
  </div>

  <input type="file" id="fileInput" accept="image/*">

  <script>
    // =====================================================
    // AudioAnalyzer Class (ported from demo8)
    // =====================================================
    class AudioAnalyzer {
      constructor(options = {}) {
        this.bufferSize = options.bufferSize || 512;

        this.audioContext = null;
        this.source = null;
        this.audioElement = null;
        this.mediaStream = null;
        this.meydaAnalyzer = null;
        this.isInitialized = false;
        this.sourceType = 'file';
        this.isPlaying = false;

        this.defaultAmplitude = 0;
        this.currentAmplitude = this.defaultAmplitude;

        // Energy tracking for manual flux calculation
        this.previousRms = 0;
        this.rms = 0;

        // Envelope state
        this.envelopeValue = 0;
        this.attackSpeed = 0.9;
        this.decaySpeed = 0.85;

        // Adaptive threshold
        this.rmsHistory = [];
        this.historySize = 43;
        this.sensitivity = 1.3;
        this.minThreshold = 0.01;

        // Peak tracking for dynamic range
        this.peakRms = 0.01;
        this.peakDecay = 0.995;
      }

      async init() {
        if (this.isInitialized) return;

        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.isInitialized = true;
      }

      setupMeydaAnalyzer() {
        if (this.meydaAnalyzer) {
          this.meydaAnalyzer.stop();
        }

        if (!this.source) return;

        if (typeof Meyda === 'undefined') {
          console.warn('Meyda not loaded - audio analysis unavailable');
          return;
        }

        this.meydaAnalyzer = Meyda.createMeydaAnalyzer({
          audioContext: this.audioContext,
          source: this.source,
          bufferSize: this.bufferSize,
          featureExtractors: ['rms'],
          callback: (features) => {
            if (features && typeof features.rms === 'number') {
              this.previousRms = this.rms;
              this.rms = features.rms;
              this.processFeatures();
            }
          },
        });

        this.meydaAnalyzer.start();
      }

      processFeatures() {
        const flux = Math.max(0, this.rms - this.previousRms);

        if (this.rms > this.peakRms) {
          this.peakRms = this.rms;
        } else {
          this.peakRms *= this.peakDecay;
          this.peakRms = Math.max(this.peakRms, 0.01);
        }

        this.rmsHistory.push(flux);
        if (this.rmsHistory.length > this.historySize) {
          this.rmsHistory.shift();
        }

        const avgFlux = this.rmsHistory.reduce((a, b) => a + b, 0) / this.rmsHistory.length;
        const threshold = Math.max(avgFlux * this.sensitivity, this.minThreshold);

        if (flux > threshold) {
          const relativeIntensity = this.rms / this.peakRms;
          const fluxIntensity = Math.min(flux / threshold, 4) / 4;
          const strength = Math.pow(relativeIntensity, 0.7) * (0.5 + fluxIntensity * 0.5);
          this.envelopeValue = this.envelopeValue + (strength - this.envelopeValue) * this.attackSpeed;
        } else {
          this.envelopeValue *= this.decaySpeed;
        }

        this.currentAmplitude = Math.min(Math.max(this.envelopeValue, 0), 1);
      }

      async loadAudioFile(url) {
        await this.init();
        this.disconnectSource();

        if (!this.audioElement) {
          this.audioElement = new Audio();
          this.audioElement.crossOrigin = 'anonymous';
          this.audioElement.loop = true;
        }

        this.audioElement.src = url;

        this.source = this.audioContext.createMediaElementSource(this.audioElement);
        this.source.connect(this.audioContext.destination);

        this.setupMeydaAnalyzer();
        this.sourceType = 'file';

        return new Promise((resolve, reject) => {
          this.audioElement.addEventListener('canplaythrough', () => resolve(), { once: true });
          this.audioElement.addEventListener('error', reject, { once: true });
          this.audioElement.load();
        });
      }

      async connectMicrophone() {
        await this.init();
        this.disconnectSource();

        try {
          this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.source = this.audioContext.createMediaStreamSource(this.mediaStream);

          this.setupMeydaAnalyzer();
          this.sourceType = 'mic';
          this.isPlaying = true;
        } catch (error) {
          console.error('Microphone access denied:', error);
          throw error;
        }
      }

      disconnectSource() {
        if (this.meydaAnalyzer) {
          this.meydaAnalyzer.stop();
          this.meydaAnalyzer = null;
        }

        if (this.source) {
          this.source.disconnect();
          this.source = null;
        }

        if (this.mediaStream) {
          this.mediaStream.getTracks().forEach(track => track.stop());
          this.mediaStream = null;
        }

        if (this.audioElement) {
          this.audioElement.pause();
          this.audioElement.src = '';
          this.audioElement = null;
        }

        this.rmsHistory = [];
        this.envelopeValue = 0;
        this.previousRms = 0;
        this.rms = 0;
        this.peakRms = 0.01;
        this.isPlaying = false;
      }

      async togglePlay() {
        if (this.sourceType !== 'file' || !this.audioElement) return false;

        if (this.audioContext.state === 'suspended') {
          await this.audioContext.resume();
        }

        if (this.isPlaying) {
          this.audioElement.pause();
          this.isPlaying = false;
        } else {
          await this.audioElement.play();
          this.isPlaying = true;
        }

        return this.isPlaying;
      }

      getAmplitude() {
        if (!this.isPlaying && this.sourceType === 'file') {
          return this.defaultAmplitude;
        }
        return this.currentAmplitude || this.defaultAmplitude;
      }

      dispose() {
        this.disconnectSource();
        if (this.audioContext) {
          this.audioContext.close();
        }
      }
    }

    // =====================================================
    // Vertex Shader (with ripple displacement)
    // =====================================================
    const vertexShaderSource = `
      #define PI 3.14159265359

      varying vec2 vUv;
      varying float vRipple;

      uniform float uTime;
      uniform float uAmplitude;
      uniform float uRippleFreq;
      uniform float uRippleProgress;
      uniform float uHoverProgress;

      void main() {
        vec3 pos = position;

        // Ripple from center (0.5, 0.5)
        float dist = distance(uv, vec2(0.5, 0.5));
        float decay = clamp(dist, 8.0, 10.0);
        float ripple = sin(-PI * uRippleFreq * dist + uTime) * (uAmplitude / decay);
        ripple *= uRippleProgress * uHoverProgress;

        // Displace Y position for visible warping (not Z)
        pos.y += ripple;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        vUv = uv;
        vRipple = ripple;
      }
    `;

    // =====================================================
    // Fragment Shader (color processing + ripple brightness)
    // =====================================================
    const fragmentShaderSource = `
      precision highp float;

      varying vec2 vUv;
      varying float vRipple;

      uniform sampler2D uTexture;
      uniform float uTime;
      uniform float uPaletteTime;
      uniform float uSpeed;
      uniform float uFrequency;
      uniform float uIntensity;
      uniform float uStrength;
      uniform vec2 uResolution;
      uniform float uImageAspect;
      uniform float uCanvasAspect;
      uniform float uHueStart;
      uniform float uHueRange;
      uniform float uRippleProgress;
      uniform bool uPaletteEnabled;

      // Grain uniforms
      uniform bool uGrainEnabled;
      uniform float uGrainIntensity;
      uniform float uGrainScale;
      uniform bool uGrainAnimated;
      uniform float uGrainSpeed;

      // Post-processing uniforms
      uniform bool uBloomEnabled;
      uniform float uBloomIntensity;
      uniform float uBloomThreshold;
      uniform bool uBlurEnabled;
      uniform float uBlurStrength;

      // Hover mode uniform
      uniform float uHoverProgress; // 0 = no effects, 1 = full effects

      // =====================================================
      // Simplex Noise (webgl-noise by Ashima Arts, MIT License)
      // =====================================================
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

      float snoise(vec2 v) {
        const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                           -0.577350269189626, 0.024390243902439);
        vec2 i  = floor(v + dot(v, C.yy));
        vec2 x0 = v - i + dot(i, C.xx);
        vec2 i1;
        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
        i = mod289(i);
        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                                + i.x + vec3(0.0, i1.x, 1.0));
        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                                dot(x12.zw,x12.zw)), 0.0);
        m = m*m;
        m = m*m;
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
        vec3 g;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
      }

      // Screen blend mode
      vec3 screenBlend(vec3 base, vec3 blend) {
        return 1.0 - (1.0 - base) * (1.0 - blend);
      }

      // Luminance calculation
      float luminance(vec3 color) {
        return dot(color, vec3(0.299, 0.587, 0.114));
      }

      // 9-point Gaussian blur
      vec4 blur9(sampler2D image, vec2 uv, vec2 texelSize, float strength) {
        vec4 color = vec4(0.0);
        vec2 off = texelSize * strength;

        color += texture2D(image, uv + off * vec2(-1.0,  1.0)) * 0.0625;
        color += texture2D(image, uv + off * vec2( 0.0,  1.0)) * 0.125;
        color += texture2D(image, uv + off * vec2( 1.0,  1.0)) * 0.0625;
        color += texture2D(image, uv + off * vec2(-1.0,  0.0)) * 0.125;
        color += texture2D(image, uv)                          * 0.25;
        color += texture2D(image, uv + off * vec2( 1.0,  0.0)) * 0.125;
        color += texture2D(image, uv + off * vec2(-1.0, -1.0)) * 0.0625;
        color += texture2D(image, uv + off * vec2( 0.0, -1.0)) * 0.125;
        color += texture2D(image, uv + off * vec2( 1.0, -1.0)) * 0.0625;

        return color;
      }

      // RGB to HSL conversion
      vec3 rgb2hsl(vec3 c) {
        float maxC = max(c.r, max(c.g, c.b));
        float minC = min(c.r, min(c.g, c.b));
        float l = (maxC + minC) * 0.5;

        if (maxC == minC) {
          return vec3(0.0, 0.0, l);
        }

        float d = maxC - minC;
        float s = l > 0.5 ? d / (2.0 - maxC - minC) : d / (maxC + minC);

        float h;
        if (maxC == c.r) {
          h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
        } else if (maxC == c.g) {
          h = (c.b - c.r) / d + 2.0;
        } else {
          h = (c.r - c.g) / d + 4.0;
        }
        h /= 6.0;

        return vec3(h, s, l);
      }

      // Hue to RGB helper
      float hue2rgb(float p, float q, float t) {
        if (t < 0.0) t += 1.0;
        if (t > 1.0) t -= 1.0;
        if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
        if (t < 1.0/2.0) return q;
        if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
        return p;
      }

      // HSL to RGB conversion
      vec3 hsl2rgb(vec3 hsl) {
        float h = hsl.x;
        float s = hsl.y;
        float l = hsl.z;

        if (s == 0.0) {
          return vec3(l);
        }

        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
        float p = 2.0 * l - q;

        float r = hue2rgb(p, q, h + 1.0/3.0);
        float g = hue2rgb(p, q, h);
        float b = hue2rgb(p, q, h - 1.0/3.0);

        return vec3(r, g, b);
      }

      void main() {
        vec2 uv = vUv;

        // Apply grain UV displacement (pre-texture sampling)
        if (uGrainEnabled) {
          // Scale controls grain size (higher = finer grain)
          vec2 noiseCoord = gl_FragCoord.xy / uGrainScale;

          // Add time offset for animation if enabled
          if (uGrainAnimated) {
            noiseCoord += uTime * uGrainSpeed;
          }

          // Generate noise and apply displacement (scaled by hover progress)
          float noise = snoise(noiseCoord);
          float grainAmount = uGrainIntensity * uHoverProgress;
          uv.x += noise * grainAmount;
          uv.y += noise * grainAmount;
        }

        vec4 texColor = texture2D(uTexture, uv);
        vec3 finalColor;

        if (uPaletteEnabled) {
          // Convert to HSL
          vec3 hsl = rgb2hsl(texColor.rgb);
          float luma = hsl.z;

          // Time-based animation (uses separate palette time)
          float timeOffset = uPaletteTime * uSpeed * 0.02;
          float lumaPosition = luma * uIntensity * 0.2;
          float hue = uHueStart + fract(lumaPosition + timeOffset) * uHueRange;
          hsl.x = fract(hue);

          // Saturation boost
          hsl.y = min(1.0, hsl.y + uStrength * 0.15);

          // Luminance adjustment
          hsl.z = hsl.z * (0.8 + uFrequency * 0.05) + 0.1;
          hsl.z = clamp(hsl.z, 0.0, 1.0);

          // Convert back to RGB and mix with original based on hover progress
          vec3 paletteColor = hsl2rgb(hsl);
          finalColor = mix(texColor.rgb, paletteColor, uHoverProgress);
        } else {
          // No palette - use original colors
          finalColor = texColor.rgb;
        }

        // Add ripple brightness variation
        finalColor += vRipple * 2.0 * uRippleProgress;

        // Apply blur effect
        if (uBlurEnabled) {
          vec2 texelSize = 1.0 / uResolution;
          vec4 blurredColor = blur9(uTexture, uv, texelSize, uBlurStrength * 2.0);

          vec3 processedBlur;
          if (uPaletteEnabled) {
            // Apply palette color processing to blurred samples
            vec3 blurHsl = rgb2hsl(blurredColor.rgb);
            float blurLuma = blurHsl.z;
            float blurTimeOffset = uPaletteTime * uSpeed * 0.02;
            float blurLumaPosition = blurLuma * uIntensity * 0.2;
            float blurHue = uHueStart + fract(blurLumaPosition + blurTimeOffset) * uHueRange;
            blurHsl.x = fract(blurHue);
            blurHsl.y = min(1.0, blurHsl.y + uStrength * 0.15);
            blurHsl.z = blurHsl.z * (0.8 + uFrequency * 0.05) + 0.1;
            blurHsl.z = clamp(blurHsl.z, 0.0, 1.0);
            processedBlur = hsl2rgb(blurHsl);
          } else {
            // Use original blurred colors without palette processing
            processedBlur = blurredColor.rgb;
          }

          finalColor = mix(finalColor, processedBlur, uBlurStrength * 0.1 * uHoverProgress);
        }

        // Apply bloom effect
        if (uBloomEnabled) {
          float lum = luminance(finalColor);
          float threshold = uBloomThreshold * 0.1;
          float bloomMask = smoothstep(threshold, threshold + 0.1, lum);
          vec3 bloomColor = finalColor * bloomMask;

          vec2 texelSize = 1.0 / uResolution;
          vec3 bloomBlur = vec3(0.0);
          float blurRadius = uBloomIntensity * 0.5;

          for (float x = -2.0; x <= 2.0; x += 1.0) {
            for (float y = -2.0; y <= 2.0; y += 1.0) {
              vec2 offset = vec2(x, y) * texelSize * blurRadius;
              vec4 sampleColor = texture2D(uTexture, uv + offset);
              vec3 sampleHsl = rgb2hsl(sampleColor.rgb);
              float sampleLum = sampleHsl.z;
              if (sampleLum > threshold) {
                bloomBlur += sampleColor.rgb * (sampleLum - threshold);
              }
            }
          }
          bloomBlur /= 25.0;

          vec3 bloomProcessed = bloomBlur * (uBloomIntensity * 0.3 * uHoverProgress);
          finalColor = screenBlend(finalColor, bloomProcessed);
        }

        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

    // =====================================================
    // Wireframe Fragment Shader (dark grey)
    // =====================================================
    const wireframeFragmentShader = `
      precision highp float;

      void main() {
        gl_FragColor = vec4(0.3, 0.3, 0.3, 0.6);
      }
    `;

    // =====================================================
    // Three.js Setup
    // =====================================================
    const canvas = document.getElementById('glCanvas');

    // Create renderer
    const renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance'
    });
    renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Create scene
    const scene = new THREE.Scene();

    // Create orthographic camera (sized to viewport)
    const { innerWidth: width, innerHeight: height } = window;
    const camera = new THREE.OrthographicCamera(
      -width / 2, width / 2,
      height / 2, -height / 2,
      -1000, 1000
    );
    camera.position.z = 10;

    // Create geometry with high subdivision for smooth ripple
    const geometry = new THREE.PlaneGeometry(1, 1, 100, 100);

    // Image display settings
    const maxImageWidth = 600;  // Max width like index8
    const imageAspectRatio = 4 / 3;  // Default aspect ratio

    // Create shader material
    let material;
    let mesh;
    let texture;

    // Wireframe overlay
    let wireframeMaterial;
    let wireframeMesh;
    let wireframeEnabled = false;
    let imageVisible = true;

    // State variables
    let speed = 0.5;
    let frequency = 4;
    let intensity = 2.5;
    let strength = 2.5;
    let imageLoaded = false;
    let imageAspect = 1;

    // Palette state (full spectrum: hueStart=0, hueRange=1)
    let paletteEnabled = true;
    const hueStart = 0.0;
    const hueRange = 1.0;

    // Ripple state
    let rippleEnabled = true;
    let rippleFreq = 13.5;
    let rippleAmplitude = 0.05;
    let rippleSpeed = 0.05;
    let rippleTime = 0;

    // Palette time (independent of ripple)
    let paletteTime = 0;

    // Post-processing state
    let bloomEnabled = true;
    let bloomIntensity = 7.5;
    let bloomThreshold = 5;
    let blurEnabled = true;
    let blurStrength = 5;

    // Grain state
    let grainEnabled = true;
    let grainIntensity = 0.02;
    let grainScale = 2.5;
    let grainAnimated = true;
    let grainSpeed = 0.75;

    // Mode state
    let currentMode = 'edit'; // 'edit' or 'hover'
    let isHovering = false;
    let hoverProgress = 1; // 0 = no effects, 1 = full effects (start at 1 for edit mode)
    let volumeProgress = 1; // 0.05 = ducked, 1 = full volume (for hover mode audio ducking)

    // Audio analyzer
    const audioAnalyzer = new AudioAnalyzer({ bufferSize: 512 });
    const audioMultiplier = 0.3;
    const maxAmplitude = 0.35;

    // Default values for reset
    const defaults = {
      paletteEnabled: true, speed: 0.5, frequency: 4, intensity: 2.5, strength: 2.5,
      rippleEnabled: true, rippleFreq: 13.5, rippleAmplitude: 0.05, rippleSpeed: 0.05,
      imageVisible: true, wireframeEnabled: false,
      bloomEnabled: true, bloomIntensity: 7.5, bloomThreshold: 5,
      blurEnabled: true, blurStrength: 5,
      grainEnabled: true, grainIntensity: 0.02, grainScale: 2.5, grainAnimated: true, grainSpeed: 0.75
    };

    // Create material with uniforms
    function createMaterial(tex) {
      return new THREE.ShaderMaterial({
        vertexShader: vertexShaderSource,
        fragmentShader: fragmentShaderSource,
        uniforms: {
          uTexture: { value: tex },
          uTime: { value: 0 },
          uPaletteTime: { value: 0 },
          uSpeed: { value: speed },
          uFrequency: { value: frequency },
          uIntensity: { value: intensity },
          uStrength: { value: strength },
          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          uImageAspect: { value: imageAspect },
          uCanvasAspect: { value: window.innerWidth / window.innerHeight },
          uHueStart: { value: hueStart },
          uHueRange: { value: hueRange },
          uPaletteEnabled: { value: paletteEnabled },
          uRippleProgress: { value: 0 },
          uAmplitude: { value: rippleAmplitude },
          uRippleFreq: { value: rippleFreq },
          uBloomEnabled: { value: bloomEnabled },
          uBloomIntensity: { value: bloomIntensity },
          uBloomThreshold: { value: bloomThreshold },
          uBlurEnabled: { value: blurEnabled },
          uBlurStrength: { value: blurStrength },
          uGrainEnabled: { value: grainEnabled },
          uGrainIntensity: { value: grainIntensity },
          uGrainScale: { value: grainScale },
          uGrainAnimated: { value: grainAnimated },
          uGrainSpeed: { value: grainSpeed },
          uHoverProgress: { value: hoverProgress }
        }
      });
    }

    // Calculate mesh size based on image aspect and viewport
    function calculateMeshSize() {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Use max width but ensure it fits in viewport with some padding
      let meshWidth = Math.min(maxImageWidth, viewportWidth * 0.8);
      let meshHeight = meshWidth / imageAspect;

      // If height exceeds viewport, scale down
      if (meshHeight > viewportHeight * 0.8) {
        meshHeight = viewportHeight * 0.8;
        meshWidth = meshHeight * imageAspect;
      }

      return { width: meshWidth, height: meshHeight };
    }

    // Create wireframe material
    function createWireframeMaterial() {
      return new THREE.ShaderMaterial({
        vertexShader: vertexShaderSource,
        fragmentShader: wireframeFragmentShader,
        wireframe: true,
        transparent: true,
        depthTest: false,
        uniforms: {
          uTime: { value: 0 },
          uAmplitude: { value: rippleAmplitude },
          uRippleFreq: { value: rippleFreq },
          uRippleProgress: { value: 0 },
          uHoverProgress: { value: hoverProgress }
        }
      });
    }

    // Load image
    function loadImage(src) {
      const loader = new THREE.TextureLoader();
      loader.load(src, (tex) => {
        texture = tex;
        imageAspect = tex.image.width / tex.image.height;

        if (mesh) {
          scene.remove(mesh);
          material.dispose();
        }

        if (wireframeMesh) {
          scene.remove(wireframeMesh);
          wireframeMaterial.dispose();
        }

        material = createMaterial(texture);
        mesh = new THREE.Mesh(geometry, material);

        // Create wireframe mesh
        wireframeMaterial = createWireframeMaterial();
        wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
        wireframeMesh.visible = wireframeEnabled;

        // Scale mesh to image size
        const size = calculateMeshSize();
        mesh.scale.set(size.width, size.height, 1);
        wireframeMesh.scale.set(size.width, size.height, 1);

        scene.add(mesh);
        scene.add(wireframeMesh);

        imageLoaded = true;
      });
    }

    // Load default image
    function loadDefaultImage() {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = function() {
        loadImage(img.src);
      };
      img.onerror = function() {
        // Fallback gradient (4:3 aspect ratio)
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 800;
        tempCanvas.height = 600;
        const ctx = tempCanvas.getContext('2d');
        const gradient = ctx.createRadialGradient(400, 300, 50, 400, 300, 400);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.5, '#666666');
        gradient.addColorStop(1, '#222222');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 800, 600);
        loadImage(tempCanvas.toDataURL());
      };
      img.src = 'statue.jpg';
    }

    // Resize handler
    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      renderer.setSize(w, h);

      // Update camera
      camera.left = -w / 2;
      camera.right = w / 2;
      camera.top = h / 2;
      camera.bottom = -h / 2;
      camera.updateProjectionMatrix();

      // Update mesh size
      if (mesh) {
        const size = calculateMeshSize();
        mesh.scale.set(size.width, size.height, 1);
        if (wireframeMesh) {
          wireframeMesh.scale.set(size.width, size.height, 1);
        }
      }

      if (material) {
        material.uniforms.uResolution.value.set(w, h);
        material.uniforms.uCanvasAspect.value = w / h;
      }

      // Update text stack position if in hover mode
      if (currentMode === 'hover') {
        const textStackEl = document.getElementById('textStack');
        if (textStackEl) {
          const meshSize = calculateMeshSize();
          const meshBottom = (h + meshSize.height) / 2;
          const meshLeft = (w - meshSize.width) / 2;
          textStackEl.style.top = (meshBottom + 20) + 'px';
          textStackEl.style.left = meshLeft + 'px';
          textStackEl.style.width = meshSize.width + 'px';
        }
      }
    }

    window.addEventListener('resize', resize);

    // Animation loop
    let startTime = Date.now();

    function render() {
      if (!imageLoaded || !material) {
        requestAnimationFrame(render);
        return;
      }

      const time = (Date.now() - startTime) / 1000;

      // Update ripple time
      rippleTime += rippleSpeed;

      // Update palette time (independent, fixed rate)
      paletteTime += 0.1;

      // Smooth hover transition (~0.6s)
      // Edit mode: always lerp toward 1
      // Hover mode: lerp toward 1 if hovering, 0 if not
      const target = (currentMode === 'edit') ? 1 : (isHovering ? 1 : 0);
      hoverProgress += (target - hoverProgress) * 0.08;

      // Audio volume ducking for hover mode (file playback only)
      // Edit mode: full volume (1.0)
      // Hover mode: ducked (0.05) when not hovering, full (1.0) when hovering
      const volumeTarget = (currentMode === 'edit') ? 1 : (isHovering ? 1 : 0.05);
      volumeProgress += (volumeTarget - volumeProgress) * 0.09;

      // Apply volume to audio element (file playback only, not mic)
      // Ease-in curve: starts slow, speeds up - softer at low volumes
      if (audioAnalyzer.audioElement && audioAnalyzer.sourceType === 'file') {
        const minVol = 0.05;
        // Normalize to 0-1 range
        const t = (volumeProgress - minVol) / (1 - minVol);
        // Apply ease-in (quadratic)
        const easedT = t * t;
        // Map back to volume range
        const easedVolume = minVol + easedT * (1 - minVol);
        audioAnalyzer.audioElement.volume = easedVolume;
      }

      // Get audio amplitude
      const audioLevel = audioAnalyzer.getAmplitude();
      const baseAmp = rippleAmplitude;
      const finalAmp = Math.min(baseAmp + (audioLevel * audioMultiplier), maxAmplitude);

      // Update uniforms
      material.uniforms.uTime.value = rippleTime;
      material.uniforms.uPaletteTime.value = paletteTime;
      material.uniforms.uSpeed.value = speed;
      material.uniforms.uFrequency.value = frequency;
      material.uniforms.uIntensity.value = intensity;
      material.uniforms.uStrength.value = strength;
      material.uniforms.uHueStart.value = hueStart;
      material.uniforms.uHueRange.value = hueRange;
      material.uniforms.uPaletteEnabled.value = paletteEnabled;
      material.uniforms.uImageAspect.value = imageAspect;
      material.uniforms.uRippleProgress.value = rippleEnabled ? 1.0 : 0.0;
      material.uniforms.uAmplitude.value = finalAmp;
      material.uniforms.uRippleFreq.value = rippleFreq;
      material.uniforms.uBloomEnabled.value = bloomEnabled;
      material.uniforms.uBloomIntensity.value = bloomIntensity;
      material.uniforms.uBloomThreshold.value = bloomThreshold;
      material.uniforms.uBlurEnabled.value = blurEnabled;
      material.uniforms.uBlurStrength.value = blurStrength;
      material.uniforms.uGrainEnabled.value = grainEnabled;
      material.uniforms.uGrainIntensity.value = grainIntensity;
      material.uniforms.uGrainScale.value = grainScale;
      material.uniforms.uGrainAnimated.value = grainAnimated;
      material.uniforms.uGrainSpeed.value = grainSpeed;
      material.uniforms.uHoverProgress.value = hoverProgress;

      // Sync wireframe uniforms
      if (wireframeMaterial) {
        wireframeMaterial.uniforms.uTime.value = rippleTime;
        wireframeMaterial.uniforms.uAmplitude.value = finalAmp;
        wireframeMaterial.uniforms.uRippleFreq.value = rippleFreq;
        wireframeMaterial.uniforms.uRippleProgress.value = rippleEnabled ? 1.0 : 0.0;
        wireframeMaterial.uniforms.uHoverProgress.value = hoverProgress;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    // =====================================================
    // UI Event Handlers
    // =====================================================

    // Slider helpers
    function updateSliderFill(slider) {
      const min = parseFloat(slider.min);
      const max = parseFloat(slider.max);
      const val = parseFloat(slider.value);
      const percent = ((val - min) / (max - min)) * 100;
      slider.style.setProperty('--value-percent', percent + '%');
    }

    function setupSlider(id, updateFn, decimals = 2) {
      const slider = document.getElementById(id);
      const valueDisplay = document.getElementById(id + 'Value');

      updateSliderFill(slider);

      slider.addEventListener('input', () => {
        const val = parseFloat(slider.value);
        valueDisplay.textContent = val.toFixed(decimals);
        updateSliderFill(slider);
        updateFn(val);
      });
    }

    // Palette sliders
    setupSlider('speed', v => speed = v);
    setupSlider('frequency', v => frequency = v);
    setupSlider('intensity', v => intensity = v);
    setupSlider('strength', v => strength = v);

    // Ripple sliders
    setupSlider('rippleFreq', v => rippleFreq = v, 1);
    setupSlider('rippleAmplitude', v => rippleAmplitude = v);
    setupSlider('rippleSpeed', v => rippleSpeed = v);

    // Post-processing sliders
    setupSlider('bloomIntensity', v => bloomIntensity = v, 1);
    setupSlider('bloomThreshold', v => bloomThreshold = v, 1);
    setupSlider('blurStrength', v => blurStrength = v, 1);

    // Grain sliders
    setupSlider('grainIntensity', v => grainIntensity = v, 3);
    setupSlider('grainScale', v => grainScale = v, 3);
    setupSlider('grainSpeed', v => grainSpeed = v, 3);

    // Effect toggles (ripple, palette, bloom, blur, wireframe)
    document.querySelectorAll('[data-effect]').forEach(option => {
      option.addEventListener('click', () => {
        const effectName = option.dataset.effect;

        if (effectName === 'ripple') {
          rippleEnabled = !rippleEnabled;
          option.classList.toggle('active', rippleEnabled);
        } else if (effectName === 'palette') {
          paletteEnabled = !paletteEnabled;
          option.classList.toggle('active', paletteEnabled);
        } else if (effectName === 'bloom') {
          bloomEnabled = !bloomEnabled;
          option.classList.toggle('active', bloomEnabled);
        } else if (effectName === 'blur') {
          blurEnabled = !blurEnabled;
          option.classList.toggle('active', blurEnabled);
        } else if (effectName === 'image') {
          imageVisible = !imageVisible;
          option.classList.toggle('active', imageVisible);
          if (mesh) {
            mesh.visible = imageVisible;
          }
        } else if (effectName === 'wireframe') {
          wireframeEnabled = !wireframeEnabled;
          option.classList.toggle('active', wireframeEnabled);
          if (wireframeMesh) {
            wireframeMesh.visible = wireframeEnabled;
          }
        } else if (effectName === 'grain') {
          grainEnabled = !grainEnabled;
          option.classList.toggle('active', grainEnabled);
        } else if (effectName === 'grainAnimated') {
          grainAnimated = !grainAnimated;
          option.classList.toggle('active', grainAnimated);
        }
      });
    });

    // Text stack element
    const textStack = document.getElementById('textStack');

    // Update text stack position based on mesh bounds
    function updateTextStackPosition() {
      const meshSize = calculateMeshSize();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      const meshBottom = (viewportHeight + meshSize.height) / 2;
      const meshLeft = (viewportWidth - meshSize.width) / 2;

      textStack.style.top = (meshBottom + 20) + 'px';
      textStack.style.left = meshLeft + 'px';
      textStack.style.width = meshSize.width + 'px';
      textStack.style.transform = 'none';
    }

    // Mode toggle (edit/hover)
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const mode = btn.dataset.mode;
        if (mode === currentMode) return;

        currentMode = mode;
        document.querySelectorAll('.mode-btn').forEach(b =>
          b.classList.toggle('active', b.dataset.mode === mode)
        );

        // Toggle controls visibility with fade
        const controlsPanel = document.querySelector('.controls-panel');
        controlsPanel.classList.toggle('hidden', mode === 'hover');

        // Toggle text stack visibility with fade
        textStack.classList.toggle('visible', mode === 'hover');
        if (mode === 'hover') {
          updateTextStackPosition();
        }

        // Reset hover state when switching modes
        // (hoverProgress will smoothly transition in render loop)
        if (mode === 'hover') {
          isHovering = false;
        } else {
          // Reset cursor when leaving hover mode
          document.body.style.cursor = 'default';
        }
      });
    });

    // Mesh hover detection for hover mode
    // Check if mouse is within the mesh bounds + gap + text stack
    document.addEventListener('mousemove', (e) => {
      if (currentMode !== 'hover') return;

      // Get mesh screen bounds (mesh is centered in viewport)
      const meshSize = calculateMeshSize();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      const meshLeft = (viewportWidth - meshSize.width) / 2;
      const meshRight = (viewportWidth + meshSize.width) / 2;
      const meshTop = (viewportHeight - meshSize.height) / 2;

      // Extend bottom bound to include text stack
      const textStackRect = textStack.getBoundingClientRect();
      const bottomBound = textStackRect.bottom;

      // Check if mouse is within extended bounds (image + gap + text)
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      isHovering = mouseX >= meshLeft && mouseX <= meshRight &&
                   mouseY >= meshTop && mouseY <= bottomBound;

      // Change cursor to pointer when hovering over the content area
      document.body.style.cursor = isHovering ? 'pointer' : 'default';
    });

    // Also handle mouse leaving the window entirely
    document.addEventListener('mouseleave', () => {
      if (currentMode === 'hover') {
        isHovering = false;
      }
    });

    // Buttons
    document.getElementById('newImageBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      speed = defaults.speed;
      frequency = defaults.frequency;
      intensity = defaults.intensity;
      strength = defaults.strength;

      const speedSlider = document.getElementById('speed');
      const frequencySlider = document.getElementById('frequency');
      const intensitySlider = document.getElementById('intensity');
      const strengthSlider = document.getElementById('strength');

      speedSlider.value = speed;
      frequencySlider.value = frequency;
      intensitySlider.value = intensity;
      strengthSlider.value = strength;

      updateSliderFill(speedSlider);
      updateSliderFill(frequencySlider);
      updateSliderFill(intensitySlider);
      updateSliderFill(strengthSlider);

      document.getElementById('speedValue').textContent = speed.toFixed(2);
      document.getElementById('frequencyValue').textContent = frequency.toFixed(2);
      document.getElementById('intensityValue').textContent = intensity.toFixed(2);
      document.getElementById('strengthValue').textContent = strength.toFixed(2);

      // Reset palette
      paletteEnabled = defaults.paletteEnabled;

      // Reset ripple
      rippleEnabled = defaults.rippleEnabled;
      rippleFreq = defaults.rippleFreq;
      rippleAmplitude = defaults.rippleAmplitude;
      rippleSpeed = defaults.rippleSpeed;

      const rippleFreqSlider = document.getElementById('rippleFreq');
      const rippleAmplitudeSlider = document.getElementById('rippleAmplitude');
      const rippleSpeedSlider = document.getElementById('rippleSpeed');

      rippleFreqSlider.value = rippleFreq;
      rippleAmplitudeSlider.value = rippleAmplitude;
      rippleSpeedSlider.value = rippleSpeed;

      updateSliderFill(rippleFreqSlider);
      updateSliderFill(rippleAmplitudeSlider);
      updateSliderFill(rippleSpeedSlider);

      document.getElementById('rippleFreqValue').textContent = rippleFreq.toFixed(1);
      document.getElementById('rippleAmplitudeValue').textContent = rippleAmplitude.toFixed(2);
      document.getElementById('rippleSpeedValue').textContent = rippleSpeed.toFixed(2);

      // Reset image visibility
      imageVisible = defaults.imageVisible;
      if (mesh) {
        mesh.visible = imageVisible;
      }

      // Reset wireframe
      wireframeEnabled = defaults.wireframeEnabled;
      if (wireframeMesh) {
        wireframeMesh.visible = wireframeEnabled;
      }

      // Reset post-processing
      bloomEnabled = defaults.bloomEnabled;
      bloomIntensity = defaults.bloomIntensity;
      bloomThreshold = defaults.bloomThreshold;
      blurEnabled = defaults.blurEnabled;
      blurStrength = defaults.blurStrength;

      const bloomIntensitySlider = document.getElementById('bloomIntensity');
      const bloomThresholdSlider = document.getElementById('bloomThreshold');
      const blurStrengthSlider = document.getElementById('blurStrength');

      bloomIntensitySlider.value = bloomIntensity;
      bloomThresholdSlider.value = bloomThreshold;
      blurStrengthSlider.value = blurStrength;

      updateSliderFill(bloomIntensitySlider);
      updateSliderFill(bloomThresholdSlider);
      updateSliderFill(blurStrengthSlider);

      document.getElementById('bloomIntensityValue').textContent = bloomIntensity.toFixed(1);
      document.getElementById('bloomThresholdValue').textContent = bloomThreshold.toFixed(1);
      document.getElementById('blurStrengthValue').textContent = blurStrength.toFixed(1);

      // Reset grain
      grainEnabled = defaults.grainEnabled;
      grainIntensity = defaults.grainIntensity;
      grainScale = defaults.grainScale;
      grainAnimated = defaults.grainAnimated;
      grainSpeed = defaults.grainSpeed;

      const grainIntensitySlider = document.getElementById('grainIntensity');
      const grainScaleSlider = document.getElementById('grainScale');
      const grainSpeedSlider = document.getElementById('grainSpeed');

      grainIntensitySlider.value = grainIntensity;
      grainScaleSlider.value = grainScale;
      grainSpeedSlider.value = grainSpeed;

      updateSliderFill(grainIntensitySlider);
      updateSliderFill(grainScaleSlider);
      updateSliderFill(grainSpeedSlider);

      document.getElementById('grainIntensityValue').textContent = grainIntensity.toFixed(3);
      document.getElementById('grainScaleValue').textContent = grainScale.toFixed(3);
      document.getElementById('grainSpeedValue').textContent = grainSpeed.toFixed(3);

      // Reset effect toggle UI states
      document.querySelectorAll('[data-effect]').forEach(opt => {
        const effect = opt.dataset.effect;
        if (effect === 'palette') {
          opt.classList.toggle('active', defaults.paletteEnabled);
        } else if (effect === 'ripple') {
          opt.classList.toggle('active', defaults.rippleEnabled);
        } else if (effect === 'image') {
          opt.classList.toggle('active', defaults.imageVisible);
        } else if (effect === 'wireframe') {
          opt.classList.toggle('active', defaults.wireframeEnabled);
        } else if (effect === 'bloom') {
          opt.classList.toggle('active', defaults.bloomEnabled);
        } else if (effect === 'blur') {
          opt.classList.toggle('active', defaults.blurEnabled);
        } else if (effect === 'grain') {
          opt.classList.toggle('active', defaults.grainEnabled);
        } else if (effect === 'grainAnimated') {
          opt.classList.toggle('active', defaults.grainAnimated);
        }
      });
    });

    // File input
    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          loadImage(event.target.result);
        };
        reader.readAsDataURL(file);
      }
    });

    // Drag and drop
    const dropZone = document.getElementById('dropZone');

    document.body.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('active');
    });

    document.body.addEventListener('dragleave', (e) => {
      e.preventDefault();
      if (e.relatedTarget === null || !document.body.contains(e.relatedTarget)) {
        dropZone.classList.remove('active');
      }
    });

    document.body.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('active');

      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (event) => {
          loadImage(event.target.result);
        };
        reader.readAsDataURL(file);
      }
    });

    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropZone.classList.remove('active');
    });

    // Section expand/collapse
    document.querySelectorAll('.row-header').forEach(header => {
      header.addEventListener('click', () => {
        const section = header.closest('.section');
        const rows = section.querySelectorAll('.section-content .row');
        const isCollapsing = !section.classList.contains('collapsed');
        const staggerDelay = 0.4;

        if (isCollapsing) {
          rows.forEach((row, index) => {
            const delay = (rows.length - 1 - index) * staggerDelay;
            row.style.setProperty('--row-delay', `${delay}s`);
            const inner = row.querySelector('.row-inner');
            if (inner) inner.style.setProperty('--row-delay', `${delay}s`);
          });
          section.classList.add('collapsed');
        } else {
          rows.forEach((row, index) => {
            const delay = index * staggerDelay;
            row.style.setProperty('--row-delay', `${delay}s`);
            const inner = row.querySelector('.row-inner');
            if (inner) inner.style.setProperty('--row-delay', `${delay}s`);
          });
          section.classList.remove('collapsed');
        }
      });
    });

    // =====================================================
    // Audio Controls
    // =====================================================
    const audioPlayToggle = document.getElementById('audio-play-toggle');
    const audioChooseFileBtn = document.getElementById('audioChooseFileBtn');
    const audioMicBtn = document.getElementById('audioMicBtn');
    const audioFileInput = document.getElementById('audioFileInput');

    audioFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        await audioAnalyzer.init();
        const url = URL.createObjectURL(file);
        await audioAnalyzer.loadAudioFile(url);

        const isPlaying = await audioAnalyzer.togglePlay();
        audioPlayToggle.classList.toggle('active', isPlaying);
      }
    });

    audioPlayToggle.addEventListener('click', async () => {
      await audioAnalyzer.init();

      if (!audioAnalyzer.audioElement?.src) {
        audioFileInput.click();
        return;
      }

      const isPlaying = await audioAnalyzer.togglePlay();
      audioPlayToggle.classList.toggle('active', isPlaying);
    });

    audioChooseFileBtn.addEventListener('click', () => {
      audioFileInput.click();
    });

    audioMicBtn.addEventListener('click', async () => {
      await audioAnalyzer.init();

      if (audioAnalyzer.sourceType === 'mic' && audioAnalyzer.isPlaying) {
        audioAnalyzer.disconnectSource();
        audioMicBtn.textContent = 'USE MIC';
        audioMicBtn.classList.remove('active');
        audioPlayToggle.classList.remove('active');
      } else {
        try {
          await audioAnalyzer.connectMicrophone();
          audioMicBtn.textContent = 'STOP MIC';
          audioMicBtn.classList.add('active');
          audioPlayToggle.classList.remove('active');
        } catch (e) {
          alert('Microphone access denied. Please allow microphone access.');
        }
      }
    });

    // =====================================================
    // Start
    // =====================================================
    loadDefaultImage();
    render();
  </script>
</body>
</html>
